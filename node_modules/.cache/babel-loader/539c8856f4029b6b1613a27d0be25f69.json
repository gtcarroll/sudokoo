{"ast":null,"code":"//import React from \"react\";\n// const PointingTuple = (props) => {\n//   return <h2>pointing tuple</h2>;\n// };\nexport const pointingTuple = {\n  name: \"Pointing Tuple\",\n  test: [[0, 0, 0, 0, 0, 0, 3, 9, 5], [5, 0, 0, 0, 7, 0, 0, 2, 0], [0, 0, 0, 6, 0, 5, 7, 1, 0], [0, 0, 0, 5, 0, 4, 0, 6, 0], [0, 0, 0, 7, 0, 3, 0, 0, 0], [0, 4, 5, 0, 0, 0, 0, 0, 0], [0, 1, 3, 0, 5, 0, 0, 7, 0], [0, 5, 0, 0, 8, 7, 0, 0, 2], [2, 0, 7, 0, 0, 0, 0, 0, 0]],\n  check: (cell, state, showcase) => {\n    let indexes = [cell.row, cell.col];\n    let wasUpdated = false;\n    let unseen = [];\n\n    for (let i = 0; i < 9; i++) if (cell.notes[i] > 0) unseen.push(i); // for each house in that axis...\n\n\n    for (let c = 0; c < 9; c++) {\n      let other = axis[c]; // ...if that cell is not in the same house...\n\n      if (other.house !== cell.house) {\n        // ...remove its suspects from the unseen list...\n        for (let n = 0; n < 9; n++) {\n          if (other.val <= 0 && other.notes[n] > 0 && unseen.includes(n)) {\n            unseen.splice(unseen.indexOf(n), 1);\n          }\n        }\n      }\n    } // ...if there are any unseen suspects left...\n\n\n    if (unseen.length > 0) {\n      let soln = unseen[0] + 1;\n      let notOnlyOne = false;\n\n      for (let r = 0; r < 9; r++) {\n        let roomie = state.sudoku.houses[cell.house][r];\n        notOnlyOne |= r !== cell.room && roomie.val <= 0 && roomie.notes[soln - 1] > 0 && unseen.includes(soln - 1);\n      } // ...if this cell is not the only one in its axis and house w soln in suspects...\n\n\n      if (notOnlyOne) {\n        // ...for each other unsolved cell in the same house...\n        for (let r = 0; r < 9; r++) {\n          if (r !== cell.room) {\n            let aff = state.sudoku.houses[cell.house][r];\n            let affIndexes = [aff.row, aff.col]; // ...if aff would be affected and is not in the same axis as cell...\n\n            if (aff.val <= 0 && aff.notes[soln - 1] > 0 && affIndexes[a] !== indexes[a]) {\n              wasUpdated = true; // ...remove the soln from that cell's suspects.\n\n              aff.notes[soln - 1] = 0; // ...cross out the soln in the showcase.\n\n              showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n            }\n          }\n        }\n\n        if (wasUpdated) {\n          for (let r = 0; r < 9; r++) {\n            let aff = state.sudoku.houses[cell.house][r];\n            let affIndexes = [aff.row, aff.col]; // ...if aff would be affected and is in the same axis as cell...\n\n            if (aff.val <= 0 && aff.notes[soln - 1] > 0 && affIndexes[a] === indexes[a]) {\n              // ...highlight the soln val in state.\n              aff.notes[soln - 1] = 3; // ...highlight the soln val in the showcase.\n\n              showcase.houses[aff.house][aff.room].notes[soln - 1] = 2;\n            }\n          }\n        }\n      }\n    } // ...if updates to sudoku state were made, return them\n\n\n    if (wasUpdated) return showcase;\n    return false;\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/PointingTuple.js"],"names":["pointingTuple","name","test","check","cell","state","showcase","indexes","row","col","wasUpdated","unseen","i","notes","push","c","other","axis","house","n","val","includes","splice","indexOf","length","soln","notOnlyOne","r","roomie","sudoku","houses","room","aff","affIndexes","a"],"mappings":"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","sourcesContent":["//import React from \"react\";\n\n// const PointingTuple = (props) => {\n//   return <h2>pointing tuple</h2>;\n// };\n\nexport const pointingTuple = {\n  name: \"Pointing Tuple\",\n  test: [\n    [0, 0, 0, 0, 0, 0, 3, 9, 5],\n    [5, 0, 0, 0, 7, 0, 0, 2, 0],\n    [0, 0, 0, 6, 0, 5, 7, 1, 0],\n    [0, 0, 0, 5, 0, 4, 0, 6, 0],\n    [0, 0, 0, 7, 0, 3, 0, 0, 0],\n    [0, 4, 5, 0, 0, 0, 0, 0, 0],\n    [0, 1, 3, 0, 5, 0, 0, 7, 0],\n    [0, 5, 0, 0, 8, 7, 0, 0, 2],\n    [2, 0, 7, 0, 0, 0, 0, 0, 0],\n  ],\n  check: (cell, state, showcase) => {\n    let indexes = [cell.row, cell.col];\n    let wasUpdated = false;\n    let unseen = [];\n    for (let i = 0; i < 9; i++) if (cell.notes[i] > 0) unseen.push(i);\n\n    // for each house in that axis...\n    for (let c = 0; c < 9; c++) {\n      let other = axis[c];\n\n      // ...if that cell is not in the same house...\n      if (other.house !== cell.house) {\n        // ...remove its suspects from the unseen list...\n        for (let n = 0; n < 9; n++) {\n          if (other.val <= 0 && other.notes[n] > 0 && unseen.includes(n)) {\n            unseen.splice(unseen.indexOf(n), 1);\n          }\n        }\n      }\n    }\n\n    // ...if there are any unseen suspects left...\n    if (unseen.length > 0) {\n      let soln = unseen[0] + 1;\n      let notOnlyOne = false;\n      for (let r = 0; r < 9; r++) {\n        let roomie = state.sudoku.houses[cell.house][r];\n        notOnlyOne |=\n          r !== cell.room &&\n          roomie.val <= 0 &&\n          roomie.notes[soln - 1] > 0 &&\n          unseen.includes(soln - 1);\n      }\n      // ...if this cell is not the only one in its axis and house w soln in suspects...\n      if (notOnlyOne) {\n        // ...for each other unsolved cell in the same house...\n        for (let r = 0; r < 9; r++) {\n          if (r !== cell.room) {\n            let aff = state.sudoku.houses[cell.house][r];\n            let affIndexes = [aff.row, aff.col];\n\n            // ...if aff would be affected and is not in the same axis as cell...\n            if (\n              aff.val <= 0 &&\n              aff.notes[soln - 1] > 0 &&\n              affIndexes[a] !== indexes[a]\n            ) {\n              wasUpdated = true;\n\n              // ...remove the soln from that cell's suspects.\n              aff.notes[soln - 1] = 0;\n              // ...cross out the soln in the showcase.\n              showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n            }\n          }\n        }\n\n        if (wasUpdated) {\n          for (let r = 0; r < 9; r++) {\n            let aff = state.sudoku.houses[cell.house][r];\n            let affIndexes = [aff.row, aff.col];\n\n            // ...if aff would be affected and is in the same axis as cell...\n            if (\n              aff.val <= 0 &&\n              aff.notes[soln - 1] > 0 &&\n              affIndexes[a] === indexes[a]\n            ) {\n              // ...highlight the soln val in state.\n              aff.notes[soln - 1] = 3;\n              // ...highlight the soln val in the showcase.\n              showcase.houses[aff.house][aff.room].notes[soln - 1] = 2;\n            }\n          }\n        }\n      }\n    }\n    // ...if updates to sudoku state were made, return them\n    if (wasUpdated) return showcase;\n\n    return false;\n  },\n};\n"]},"metadata":{},"sourceType":"module"}