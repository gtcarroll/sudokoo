{"ast":null,"code":"//import React from \"react\";\n// const NakedPair = (props) => {\n//   return <h2>naked pair</h2>;\n// };\nconst countSuspects = cell => {\n  let suspects = 0;\n\n  for (let i = 0; i < cell.notes.length; i++) {\n    if (cell.notes[i] > 0) {\n      suspects++;\n    }\n  }\n\n  return suspects;\n};\n\nexport const nakedPair = {\n  name: \"Naked Pair\",\n  check: (cell, state, showcase) => {\n    if (countSuspects(cell) === 2) {\n      let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n      let indexes = [cell.row, cell.col, cell.house]; // for each axis (row, col, house) this cell belongs to...\n\n      for (let a = 0; a < 3; a++) {\n        let axis = axes[a][indexes[a]]; // ...for each cell in that axis...\n\n        for (let i = 0; i < 9; i++) {\n          let other = axis[i];\n          let isSameCell = cell.col === other.col && cell.row === other.row; // ...if cell is not the same cell and is unset...\n\n          if (!isSameCell && other.val === 0) {\n            // ...count this cell's suspects.\n            let suspects = 0;\n            let soln = -1;\n\n            for (let i = 0; i < cell.notes.length; i++) {\n              if (other.notes[i] > 0) {\n                suspects++;\n                soln = i + 1;\n              }\n            } // ...if this cell has exactly two suspects...\n\n\n            if (suspects === 2) {}\n          }\n        } // ...if there is any value remaining in our unseen list...\n\n\n        if (cell.suspects.size === 2) {\n          return showcase;\n        } // if (unseen.length > 0) {\n        //   let soln = unseen[0];\n        //   // ...set cell val to soln in state,\n        //   state.sudoku.houses[cell.house][cell.room].val = soln;\n        //   // ...highlight soln value in showcase,\n        //   showcase.houses[cell.house][cell.room].notes[soln - 1] = 2;\n        //   // ...update affected cell notes,\n        //   for (let aff of state.unsolved.values()) {\n        //     if (\n        //       aff.row === cell.row ||\n        //       aff.col === cell.col ||\n        //       aff.house === cell.house\n        //     ) {\n        //       // remove in state\n        //       state.sudoku.houses[aff.house][aff.room].notes[soln - 1] = 0;\n        //       // cross-out in showcase\n        //       showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n        //     }\n        //   }\n        // ...remove from unsolved.\n\n\n        state.unsolved.splice(state.unsolved.indexOf(cell), 1);\n        return showcase;\n      }\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/NakedPair.js"],"names":["countSuspects","cell","suspects","i","notes","length","nakedPair","name","check","state","showcase","axes","sudoku","rows","cols","houses","indexes","row","col","house","a","axis","other","isSameCell","val","soln","size","unsolved","splice","indexOf"],"mappings":"AAAA;AAEA;AACA;AACA;AAEA,MAAMA,aAAa,GAAIC,IAAD,IAAU;AAC9B,MAAIC,QAAQ,GAAG,CAAf;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,KAAL,CAAWC,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;AAC1C,QAAIF,IAAI,CAACG,KAAL,CAAWD,CAAX,IAAgB,CAApB,EAAuB;AACrBD,MAAAA,QAAQ;AACT;AACF;;AACD,SAAOA,QAAP;AACD,CARD;;AAUA,OAAO,MAAMI,SAAS,GAAG;AACvBC,EAAAA,IAAI,EAAE,YADiB;AAEvBC,EAAAA,KAAK,EAAE,CAACP,IAAD,EAAOQ,KAAP,EAAcC,QAAd,KAA2B;AAChC,QAAIV,aAAa,CAACC,IAAD,CAAb,KAAwB,CAA5B,EAA+B;AAC7B,UAAIU,IAAI,GAAG,CAACF,KAAK,CAACG,MAAN,CAAaC,IAAd,EAAoBJ,KAAK,CAACG,MAAN,CAAaE,IAAjC,EAAuCL,KAAK,CAACG,MAAN,CAAaG,MAApD,CAAX;AACA,UAAIC,OAAO,GAAG,CAACf,IAAI,CAACgB,GAAN,EAAWhB,IAAI,CAACiB,GAAhB,EAAqBjB,IAAI,CAACkB,KAA1B,CAAd,CAF6B,CAI7B;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAIC,IAAI,GAAGV,IAAI,CAACS,CAAD,CAAJ,CAAQJ,OAAO,CAACI,CAAD,CAAf,CAAX,CAD0B,CAG1B;;AACA,aAAK,IAAIjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,cAAImB,KAAK,GAAGD,IAAI,CAAClB,CAAD,CAAhB;AACA,cAAIoB,UAAU,GAAGtB,IAAI,CAACiB,GAAL,KAAaI,KAAK,CAACJ,GAAnB,IAA0BjB,IAAI,CAACgB,GAAL,KAAaK,KAAK,CAACL,GAA9D,CAF0B,CAI1B;;AACA,cAAI,CAACM,UAAD,IAAeD,KAAK,CAACE,GAAN,KAAc,CAAjC,EAAoC;AAClC;AACA,gBAAItB,QAAQ,GAAG,CAAf;AACA,gBAAIuB,IAAI,GAAG,CAAC,CAAZ;;AACA,iBAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,KAAL,CAAWC,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;AAC1C,kBAAImB,KAAK,CAAClB,KAAN,CAAYD,CAAZ,IAAiB,CAArB,EAAwB;AACtBD,gBAAAA,QAAQ;AACRuB,gBAAAA,IAAI,GAAGtB,CAAC,GAAG,CAAX;AACD;AACF,aATiC,CAWlC;;;AACA,gBAAID,QAAQ,KAAK,CAAjB,EAAoB,CACnB;AACF;AACF,SAxByB,CAyB1B;;;AAEA,YAAID,IAAI,CAACC,QAAL,CAAcwB,IAAd,KAAuB,CAA3B,EAA8B;AAC5B,iBAAOhB,QAAP;AACD,SA7ByB,CA8B1B;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACAD,QAAAA,KAAK,CAACkB,QAAN,CAAeC,MAAf,CAAsBnB,KAAK,CAACkB,QAAN,CAAeE,OAAf,CAAuB5B,IAAvB,CAAtB,EAAoD,CAApD;AACA,eAAOS,QAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;AAnEsB,CAAlB","sourcesContent":["//import React from \"react\";\n\n// const NakedPair = (props) => {\n//   return <h2>naked pair</h2>;\n// };\n\nconst countSuspects = (cell) => {\n  let suspects = 0;\n  for (let i = 0; i < cell.notes.length; i++) {\n    if (cell.notes[i] > 0) {\n      suspects++;\n    }\n  }\n  return suspects;\n};\n\nexport const nakedPair = {\n  name: \"Naked Pair\",\n  check: (cell, state, showcase) => {\n    if (countSuspects(cell) === 2) {\n      let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n      let indexes = [cell.row, cell.col, cell.house];\n\n      // for each axis (row, col, house) this cell belongs to...\n      for (let a = 0; a < 3; a++) {\n        let axis = axes[a][indexes[a]];\n\n        // ...for each cell in that axis...\n        for (let i = 0; i < 9; i++) {\n          let other = axis[i];\n          let isSameCell = cell.col === other.col && cell.row === other.row;\n\n          // ...if cell is not the same cell and is unset...\n          if (!isSameCell && other.val === 0) {\n            // ...count this cell's suspects.\n            let suspects = 0;\n            let soln = -1;\n            for (let i = 0; i < cell.notes.length; i++) {\n              if (other.notes[i] > 0) {\n                suspects++;\n                soln = i + 1;\n              }\n            }\n\n            // ...if this cell has exactly two suspects...\n            if (suspects === 2) {\n            }\n          }\n        }\n        // ...if there is any value remaining in our unseen list...\n\n        if (cell.suspects.size === 2) {\n          return showcase;\n        }\n        // if (unseen.length > 0) {\n        //   let soln = unseen[0];\n\n        //   // ...set cell val to soln in state,\n        //   state.sudoku.houses[cell.house][cell.room].val = soln;\n        //   // ...highlight soln value in showcase,\n        //   showcase.houses[cell.house][cell.room].notes[soln - 1] = 2;\n\n        //   // ...update affected cell notes,\n        //   for (let aff of state.unsolved.values()) {\n        //     if (\n        //       aff.row === cell.row ||\n        //       aff.col === cell.col ||\n        //       aff.house === cell.house\n        //     ) {\n        //       // remove in state\n        //       state.sudoku.houses[aff.house][aff.room].notes[soln - 1] = 0;\n        //       // cross-out in showcase\n        //       showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n        //     }\n        //   }\n\n        // ...remove from unsolved.\n        state.unsolved.splice(state.unsolved.indexOf(cell), 1);\n        return showcase;\n      }\n    }\n\n    return false;\n  },\n};\n"]},"metadata":{},"sourceType":"module"}