{"ast":null,"code":"//import React from \"react\";\n// const LockedCandidate = (props) => {\n//   return <h2>locked candidate</h2>;\n// };\nexport const lockedCandidate = {\n  name: \"Locked Candidate\",\n  check: (cell, state, showcase) => {\n    let axes = [state.sudoku.rows, state.sudoku.cols];\n    let indexes = [cell.row, cell.col]; // for each axis (row and col) this cell belongs to...\n\n    for (let a = 0; a < 2; a++) {\n      let axis = axes[a][indexes[a]];\n      let wasUpdated = false;\n      let unseen = [];\n\n      for (let i = 0; i < 9; i++) if (cell.notes[i] > 0) unseen.push(i); //console.log(unseen);\n      // ...for each cell in that axis...\n\n\n      for (let c = 0; c < 9; c++) {\n        let other = axis[c]; // ...if that cell is not in the same house...\n\n        if (other.house !== cell.house) {\n          // ...remove its suspects from the unseen list...\n          for (let n = 0; n < 9; n++) {\n            if (other.val <= 0 && other.notes[n] > 0 && unseen.includes(n)) {\n              unseen.splice(unseen.indexOf(n), 1);\n            }\n          } //console.log(\"removing: \" + other.notes);\n\n        }\n      } // ...if there are any unseen suspects left...\n\n\n      if (unseen.length > 0) {\n        let soln = unseen[0] + 1;\n        let notOnlyOne = false;\n\n        for (let r = 0; r < 9; r++) {\n          let roomie = state.sudoku.houses[cell.house][r];\n          notOnlyOne |= r !== cell.room && roomie.val <= 0 && roomie.notes[soln - 1] > 0 && unseen.includes(soln - 1);\n        } // ...if this cell is not the only one in its axis and house w soln in suspects...\n\n\n        if (notOnlyOne) {\n          console.log(soln);\n          console.log(unseen); // ...for each other unsolved cell in the same house...\n\n          for (let r = 0; r < 9; r++) {\n            if (r !== cell.room) {\n              let aff = state.sudoku.houses[cell.house][r];\n              let affIndexes = [aff.row, aff.col]; // ...if aff would be affected...\n\n              if (aff.notes[soln - 1] > 0) {\n                // ...if aff is not in the same axis as cell...\n                if (affIndexes[a] !== indexes[a]) {\n                  wasUpdated = true; // ...remove the soln from that cell's suspects.\n\n                  aff.notes[soln - 1] = -1; // ...cross out the soln in the showcase.\n\n                  showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n                } else {\n                  // ...highlight the soln val in the showcase.\n                  showcase.houses[aff.house][aff.room].notes[soln - 1] = 2;\n                }\n              }\n            }\n          }\n        }\n      } // ...if updates to sudoku state were made, return them\n\n\n      if (wasUpdated) return showcase;\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/LockedCandidate.js"],"names":["lockedCandidate","name","check","cell","state","showcase","axes","sudoku","rows","cols","indexes","row","col","a","axis","wasUpdated","unseen","i","notes","push","c","other","house","n","val","includes","splice","indexOf","length","soln","notOnlyOne","r","roomie","houses","room","console","log","aff","affIndexes"],"mappings":"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","sourcesContent":["//import React from \"react\";\n\n// const LockedCandidate = (props) => {\n//   return <h2>locked candidate</h2>;\n// };\n\nexport const lockedCandidate = {\n  name: \"Locked Candidate\",\n  check: (cell, state, showcase) => {\n    let axes = [state.sudoku.rows, state.sudoku.cols];\n    let indexes = [cell.row, cell.col];\n\n    // for each axis (row and col) this cell belongs to...\n    for (let a = 0; a < 2; a++) {\n      let axis = axes[a][indexes[a]];\n      let wasUpdated = false;\n      let unseen = [];\n      for (let i = 0; i < 9; i++) if (cell.notes[i] > 0) unseen.push(i);\n\n      //console.log(unseen);\n\n      // ...for each cell in that axis...\n      for (let c = 0; c < 9; c++) {\n        let other = axis[c];\n\n        // ...if that cell is not in the same house...\n        if (other.house !== cell.house) {\n          // ...remove its suspects from the unseen list...\n          for (let n = 0; n < 9; n++) {\n            if (other.val <= 0 && other.notes[n] > 0 && unseen.includes(n)) {\n              unseen.splice(unseen.indexOf(n), 1);\n            }\n          }\n          //console.log(\"removing: \" + other.notes);\n        }\n      }\n\n      // ...if there are any unseen suspects left...\n      if (unseen.length > 0) {\n        let soln = unseen[0] + 1;\n        let notOnlyOne = false;\n        for (let r = 0; r < 9; r++) {\n          let roomie = state.sudoku.houses[cell.house][r];\n          notOnlyOne |=\n            r !== cell.room &&\n            roomie.val <= 0 &&\n            roomie.notes[soln - 1] > 0 &&\n            unseen.includes(soln - 1);\n        }\n        // ...if this cell is not the only one in its axis and house w soln in suspects...\n        if (notOnlyOne) {\n          console.log(soln);\n          console.log(unseen);\n          // ...for each other unsolved cell in the same house...\n          for (let r = 0; r < 9; r++) {\n            if (r !== cell.room) {\n              let aff = state.sudoku.houses[cell.house][r];\n              let affIndexes = [aff.row, aff.col];\n\n              // ...if aff would be affected...\n              if (aff.notes[soln - 1] > 0) {\n                // ...if aff is not in the same axis as cell...\n                if (affIndexes[a] !== indexes[a]) {\n                  wasUpdated = true;\n\n                  // ...remove the soln from that cell's suspects.\n                  aff.notes[soln - 1] = -1;\n                  // ...cross out the soln in the showcase.\n                  showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n                } else {\n                  // ...highlight the soln val in the showcase.\n                  showcase.houses[aff.house][aff.room].notes[soln - 1] = 2;\n                }\n              }\n            }\n          }\n        }\n      }\n      // ...if updates to sudoku state were made, return them\n      if (wasUpdated) return showcase;\n    }\n    return false;\n  },\n};\n"]},"metadata":{},"sourceType":"module"}