{"ast":null,"code":"//import React from \"react\";\n// const HiddenSingleComponent = (props) => {\n//   return <h2>naked single</h2>;\n// };\nexport const hiddenSingle = {\n  name: \"Hidden Single\",\n  check: (cell, state) => {\n    let report = {\n      solution: 0,\n      clues: []\n    };\n    let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    let indexes = [cell.row, cell.col, cell.house]; // for each axis (row, col, house) this cell belongs to...\n\n    for (let a = 0; a < 3; a++) {\n      let axis = axes[a][indexes[a]];\n      let unseen = Array.from(cell.suspects); // ...for each cell in that axis...\n\n      for (let i = 0; i < 9; i++) {\n        let other = axis[i];\n        let isSameCell = cell.col === other.col && cell.row === other.row; // ...if cell is unset and not the same cell...\n\n        if (other.val === 0 && !isSameCell) {\n          // ...remove its suspects from our unseen list...\n          unseen = unseen.filter(u => !other.suspects.has(u));\n        }\n      } // ...if there is any value remaining in our unseen list...\n\n\n      if (unseen.length > 0) {\n        // ...return that value.\n        report.solution = {\n          row: cell.row,\n          col: cell.col,\n          val: unseen[0]\n        };\n        return report;\n      }\n    }\n\n    return report;\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/HiddenSingle.js"],"names":["hiddenSingle","name","check","cell","state","report","solution","clues","axes","sudoku","rows","cols","houses","indexes","row","col","house","a","axis","unseen","Array","from","suspects","i","other","isSameCell","val","filter","u","has","length"],"mappings":"AAAA;AAEA;AACA;AACA;AAEA,OAAO,MAAMA,YAAY,GAAG;AAC1BC,EAAAA,IAAI,EAAE,eADoB;AAE1BC,EAAAA,KAAK,EAAE,CAACC,IAAD,EAAOC,KAAP,KAAiB;AACtB,QAAIC,MAAM,GAAG;AACXC,MAAAA,QAAQ,EAAE,CADC;AAEXC,MAAAA,KAAK,EAAE;AAFI,KAAb;AAIA,QAAIC,IAAI,GAAG,CAACJ,KAAK,CAACK,MAAN,CAAaC,IAAd,EAAoBN,KAAK,CAACK,MAAN,CAAaE,IAAjC,EAAuCP,KAAK,CAACK,MAAN,CAAaG,MAApD,CAAX;AACA,QAAIC,OAAO,GAAG,CAACV,IAAI,CAACW,GAAN,EAAWX,IAAI,CAACY,GAAhB,EAAqBZ,IAAI,CAACa,KAA1B,CAAd,CANsB,CAOtB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,UAAIC,IAAI,GAAGV,IAAI,CAACS,CAAD,CAAJ,CAAQJ,OAAO,CAACI,CAAD,CAAf,CAAX;AACA,UAAIE,MAAM,GAAGC,KAAK,CAACC,IAAN,CAAWlB,IAAI,CAACmB,QAAhB,CAAb,CAF0B,CAG1B;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAIC,KAAK,GAAGN,IAAI,CAACK,CAAD,CAAhB;AACA,YAAIE,UAAU,GAAGtB,IAAI,CAACY,GAAL,KAAaS,KAAK,CAACT,GAAnB,IAA0BZ,IAAI,CAACW,GAAL,KAAaU,KAAK,CAACV,GAA9D,CAF0B,CAG1B;;AACA,YAAIU,KAAK,CAACE,GAAN,KAAc,CAAd,IAAmB,CAACD,UAAxB,EAAoC;AAClC;AACAN,UAAAA,MAAM,GAAGA,MAAM,CAACQ,MAAP,CAAeC,CAAD,IAAO,CAACJ,KAAK,CAACF,QAAN,CAAeO,GAAf,CAAmBD,CAAnB,CAAtB,CAAT;AACD;AACF,OAZyB,CAa1B;;;AACA,UAAIT,MAAM,CAACW,MAAP,GAAgB,CAApB,EAAuB;AACrB;AACAzB,QAAAA,MAAM,CAACC,QAAP,GAAkB;AAChBQ,UAAAA,GAAG,EAAEX,IAAI,CAACW,GADM;AAEhBC,UAAAA,GAAG,EAAEZ,IAAI,CAACY,GAFM;AAGhBW,UAAAA,GAAG,EAAEP,MAAM,CAAC,CAAD;AAHK,SAAlB;AAKA,eAAOd,MAAP;AACD;AACF;;AACD,WAAOA,MAAP;AACD;AAnCyB,CAArB","sourcesContent":["//import React from \"react\";\n\n// const HiddenSingleComponent = (props) => {\n//   return <h2>naked single</h2>;\n// };\n\nexport const hiddenSingle = {\n  name: \"Hidden Single\",\n  check: (cell, state) => {\n    let report = {\n      solution: 0,\n      clues: [],\n    };\n    let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    let indexes = [cell.row, cell.col, cell.house];\n    // for each axis (row, col, house) this cell belongs to...\n    for (let a = 0; a < 3; a++) {\n      let axis = axes[a][indexes[a]];\n      let unseen = Array.from(cell.suspects);\n      // ...for each cell in that axis...\n      for (let i = 0; i < 9; i++) {\n        let other = axis[i];\n        let isSameCell = cell.col === other.col && cell.row === other.row;\n        // ...if cell is unset and not the same cell...\n        if (other.val === 0 && !isSameCell) {\n          // ...remove its suspects from our unseen list...\n          unseen = unseen.filter((u) => !other.suspects.has(u));\n        }\n      }\n      // ...if there is any value remaining in our unseen list...\n      if (unseen.length > 0) {\n        // ...return that value.\n        report.solution = {\n          row: cell.row,\n          col: cell.col,\n          val: unseen[0],\n        };\n        return report;\n      }\n    }\n    return report;\n  },\n};\n"]},"metadata":{},"sourceType":"module"}