{"ast":null,"code":"//import React from \"react\";\n// const LockedCandidate = (props) => {\n//   return <h2>locked candidate</h2>;\n// };\nexport const lockedCandidate = {\n  name: \"Locked Candidate\",\n  check: (cell, state, showcase) => {\n    let axes = [state.sudoku.rows, state.sudoku.cols];\n    let indexes = [cell.row, cell.col]; // for each axis (row and col) this cell belongs to...\n\n    for (let a = 0; a < 2; a++) {\n      let axis = axes[a][indexes[a]];\n      let unseen = [];\n\n      for (let i = 0; i < 9; i++) if (cell.notes[i] > 0) unseen.push(i); // ...for each cell in that axis...\n\n\n      for (let i = 0; i < 9; i++) {\n        let wasUpdated = false;\n        let other = axis[i]; // ...if that cell is not in the same house...\n\n        if (other.house !== cell.house) {\n          // ...remove its suspects from the unseen list...\n          for (let j = 0; j < 9; j++) {\n            if (other.notes[j] > 0 && unseen.contains(j)) {\n              unseen.splice(unseen.indexOf(j), 1);\n            }\n          }\n        }\n      } // ...if there are any unseen suspects left...\n\n\n      if (unseen.length > 0) {\n        let soln = unseen[0] + 1; // ...remove the pair of values from that cell's suspects.\n\n        aff.notes[i] = -1; // ...mark the pair of values crossed out in showcase.\n\n        showcase.houses[aff.house][aff.room].notes[i] = -1;\n      }\n    } // ...if there are no cells suspecting that value in this axis in another house...\n    // if every occurance of a given value is in the same house...\n    // if (pair.length === 2) {\n    //   let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    //   let cellIndexes = [cell.row, cell.col, cell.house];\n    // ...for each axis (row, col, house) this cell belongs to...\n\n  } //     for (let a = 0; a < 3; a++) {\n  //       let axis = axes[a][cellIndexes[a]];\n  //       // ...for each cell in that axis...\n  //       for (let i = 0; i < 9; i++) {\n  //         let wasUpdated = false;\n  //         let other = axis[i];\n  //         // ...if that cell is not the same and has exactly the same two suspects...\n  //         let otherPair = getSuspects(other);\n  //         if (\n  //           !isSame(cell, other) &&\n  //           otherPair.length === 2 &&\n  //           otherPair[0] === pair[0] &&\n  //           otherPair[1] === pair[1]\n  //         ) {\n  //           let otherIndexes = [other.row, other.col, other.house];\n  //           // ...for each axis the cell's share...\n  //           for (let b = 0; b < 3; b++) {\n  //             if (cellIndexes[b] === otherIndexes[b]) {\n  //               let sharedAxis = axes[b][otherIndexes[b]];\n  //               // ...for each cell in that shared axis...\n  //               for (let j = 0; j < 9; j++) {\n  //                 let aff = sharedAxis[j];\n  //                 // ...if that cell is not in this pair and is unset...\n  //                 if (\n  //                   !isSame(aff, cell) &&\n  //                   !isSame(aff, other) &&\n  //                   aff.val <= 0\n  //                 ) {\n  //                   // ...push potential changes to cell.\n  //                   wasUpdated |= pushChanges(aff, pair[0], state, showcase);\n  //                   wasUpdated |= pushChanges(aff, pair[1], state, showcase);\n  //                 }\n  //               }\n  //             }\n  //           }\n  //         }\n  //         // ...if updates to sudoku state were made...\n  //         if (wasUpdated) {\n  //           // ...highlight the naked pair values in showcase.\n  //           showcase.houses[cell.house][cell.room].notes[pair[0]] = 2;\n  //           showcase.houses[cell.house][cell.room].notes[pair[1]] = 2;\n  //           showcase.houses[other.house][other.room].notes[pair[0]] = 2;\n  //           showcase.houses[other.house][other.room].notes[pair[1]] = 2;\n  //           return showcase;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // },\n\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/LockedCandidate.js"],"names":["lockedCandidate","name","check","cell","state","showcase","axes","sudoku","rows","cols","indexes","row","col","a","axis","unseen","i","notes","push","wasUpdated","other","house","j","contains","splice","indexOf","length","soln","aff","houses","room"],"mappings":"AAAA;AAEA;AACA;AACA;AAEA,OAAO,MAAMA,eAAe,GAAG;AAC7BC,EAAAA,IAAI,EAAE,kBADuB;AAE7BC,EAAAA,KAAK,EAAE,CAACC,IAAD,EAAOC,KAAP,EAAcC,QAAd,KAA2B;AAChC,QAAIC,IAAI,GAAG,CAACF,KAAK,CAACG,MAAN,CAAaC,IAAd,EAAoBJ,KAAK,CAACG,MAAN,CAAaE,IAAjC,CAAX;AACA,QAAIC,OAAO,GAAG,CAACP,IAAI,CAACQ,GAAN,EAAWR,IAAI,CAACS,GAAhB,CAAd,CAFgC,CAIhC;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,UAAIC,IAAI,GAAGR,IAAI,CAACO,CAAD,CAAJ,CAAQH,OAAO,CAACG,CAAD,CAAf,CAAX;AACA,UAAIE,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B,IAAIb,IAAI,CAACc,KAAL,CAAWD,CAAX,IAAgB,CAApB,EAAuBD,MAAM,CAACG,IAAP,CAAYF,CAAZ,EAHzB,CAK1B;;;AACA,WAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAIG,UAAU,GAAG,KAAjB;AACA,YAAIC,KAAK,GAAGN,IAAI,CAACE,CAAD,CAAhB,CAF0B,CAI1B;;AACA,YAAII,KAAK,CAACC,KAAN,KAAgBlB,IAAI,CAACkB,KAAzB,EAAgC;AAC9B;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,gBAAIF,KAAK,CAACH,KAAN,CAAYK,CAAZ,IAAiB,CAAjB,IAAsBP,MAAM,CAACQ,QAAP,CAAgBD,CAAhB,CAA1B,EAA8C;AAC5CP,cAAAA,MAAM,CAACS,MAAP,CAAcT,MAAM,CAACU,OAAP,CAAeH,CAAf,CAAd,EAAiC,CAAjC;AACD;AACF;AACF;AACF,OAnByB,CAqB1B;;;AACA,UAAIP,MAAM,CAACW,MAAP,GAAgB,CAApB,EAAuB;AACrB,YAAIC,IAAI,GAAGZ,MAAM,CAAC,CAAD,CAAN,GAAY,CAAvB,CADqB,CAGrB;;AACAa,QAAAA,GAAG,CAACX,KAAJ,CAAUD,CAAV,IAAe,CAAC,CAAhB,CAJqB,CAKrB;;AACAX,QAAAA,QAAQ,CAACwB,MAAT,CAAgBD,GAAG,CAACP,KAApB,EAA2BO,GAAG,CAACE,IAA/B,EAAqCb,KAArC,CAA2CD,CAA3C,IAAgD,CAAC,CAAjD;AACD;AACF,KAnC+B,CAoChC;AACA;AAEA;AACA;AACA;AAEA;;AACD,GA9C4B,CA+C7B;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtG6B,CAAxB","sourcesContent":["//import React from \"react\";\n\n// const LockedCandidate = (props) => {\n//   return <h2>locked candidate</h2>;\n// };\n\nexport const lockedCandidate = {\n  name: \"Locked Candidate\",\n  check: (cell, state, showcase) => {\n    let axes = [state.sudoku.rows, state.sudoku.cols];\n    let indexes = [cell.row, cell.col];\n\n    // for each axis (row and col) this cell belongs to...\n    for (let a = 0; a < 2; a++) {\n      let axis = axes[a][indexes[a]];\n      let unseen = [];\n      for (let i = 0; i < 9; i++) if (cell.notes[i] > 0) unseen.push(i);\n\n      // ...for each cell in that axis...\n      for (let i = 0; i < 9; i++) {\n        let wasUpdated = false;\n        let other = axis[i];\n\n        // ...if that cell is not in the same house...\n        if (other.house !== cell.house) {\n          // ...remove its suspects from the unseen list...\n          for (let j = 0; j < 9; j++) {\n            if (other.notes[j] > 0 && unseen.contains(j)) {\n              unseen.splice(unseen.indexOf(j), 1);\n            }\n          }\n        }\n      }\n\n      // ...if there are any unseen suspects left...\n      if (unseen.length > 0) {\n        let soln = unseen[0] + 1;\n\n        // ...remove the pair of values from that cell's suspects.\n        aff.notes[i] = -1;\n        // ...mark the pair of values crossed out in showcase.\n        showcase.houses[aff.house][aff.room].notes[i] = -1;\n      }\n    }\n    // ...if there are no cells suspecting that value in this axis in another house...\n    // if every occurance of a given value is in the same house...\n\n    // if (pair.length === 2) {\n    //   let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    //   let cellIndexes = [cell.row, cell.col, cell.house];\n\n    // ...for each axis (row, col, house) this cell belongs to...\n  },\n  //     for (let a = 0; a < 3; a++) {\n  //       let axis = axes[a][cellIndexes[a]];\n\n  //       // ...for each cell in that axis...\n  //       for (let i = 0; i < 9; i++) {\n  //         let wasUpdated = false;\n  //         let other = axis[i];\n\n  //         // ...if that cell is not the same and has exactly the same two suspects...\n  //         let otherPair = getSuspects(other);\n  //         if (\n  //           !isSame(cell, other) &&\n  //           otherPair.length === 2 &&\n  //           otherPair[0] === pair[0] &&\n  //           otherPair[1] === pair[1]\n  //         ) {\n  //           let otherIndexes = [other.row, other.col, other.house];\n\n  //           // ...for each axis the cell's share...\n  //           for (let b = 0; b < 3; b++) {\n  //             if (cellIndexes[b] === otherIndexes[b]) {\n  //               let sharedAxis = axes[b][otherIndexes[b]];\n\n  //               // ...for each cell in that shared axis...\n  //               for (let j = 0; j < 9; j++) {\n  //                 let aff = sharedAxis[j];\n\n  //                 // ...if that cell is not in this pair and is unset...\n  //                 if (\n  //                   !isSame(aff, cell) &&\n  //                   !isSame(aff, other) &&\n  //                   aff.val <= 0\n  //                 ) {\n  //                   // ...push potential changes to cell.\n  //                   wasUpdated |= pushChanges(aff, pair[0], state, showcase);\n  //                   wasUpdated |= pushChanges(aff, pair[1], state, showcase);\n  //                 }\n  //               }\n  //             }\n  //           }\n  //         }\n\n  //         // ...if updates to sudoku state were made...\n  //         if (wasUpdated) {\n  //           // ...highlight the naked pair values in showcase.\n  //           showcase.houses[cell.house][cell.room].notes[pair[0]] = 2;\n  //           showcase.houses[cell.house][cell.room].notes[pair[1]] = 2;\n  //           showcase.houses[other.house][other.room].notes[pair[0]] = 2;\n  //           showcase.houses[other.house][other.room].notes[pair[1]] = 2;\n  //           return showcase;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // },\n};\n"]},"metadata":{},"sourceType":"module"}