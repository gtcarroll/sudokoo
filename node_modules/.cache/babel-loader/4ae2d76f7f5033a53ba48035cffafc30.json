{"ast":null,"code":"//import React from \"react\";\n// const NakedSingleComponent = (props) => {\n//   return <h2>naked single</h2>;\n// };\nexport const nakedSingle = {\n  name: \"Naked Single\",\n  check: (cell, state, showcase) => {\n    // if this cell has only one suspect...\n    let suspects = 0;\n\n    for (let i = 0; i < cell.notes.length; i++) {\n      if (cell.notes[i] > 0) suspects++;\n    }\n\n    if (suspects === 1) {\n      // ...report that suspect's value.\n      // TODO: replace this...\n      // ...with this\n      // 1) create a copy of state.sudoku\n      // 2) update this cell in the copy cell w new value\n      let soln = cell.suspects.values().next().value;\n      state.sudoku.rows[cell.row][cell.col].val = soln;\n      showcase.rows[cell.row][cell.col].notes[soln - 1] = 1; // update affected notes\n      // update affected cell notes\n\n      for (let aff of state.unsolved.values()) {\n        // TODO: this behavior must be able to manage technique-specific note updates\n        if (aff.row === cell.row || aff.col === cell.col || aff.house === cell.house) {\n          //findSuspects(aff);\n          state.sudoku.houses[aff.house][aff.room].notes[soln - 1] = 0;\n          showcase.rows[aff.house][aff.room].notes[soln - 1] = -1;\n        }\n      }\n\n      let pos = state.unsolved.indexOf(cell);\n      state.unsolved.splice(pos, 1); // 3) return the new sudoku\n\n      return showcase;\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/NakedSingle.js"],"names":["nakedSingle","name","check","cell","state","showcase","suspects","i","notes","length","soln","values","next","value","sudoku","rows","row","col","val","aff","unsolved","house","houses","room","pos","indexOf","splice"],"mappings":"AAAA;AAEA;AACA;AACA;AAEA,OAAO,MAAMA,WAAW,GAAG;AACzBC,EAAAA,IAAI,EAAE,cADmB;AAEzBC,EAAAA,KAAK,EAAE,CAACC,IAAD,EAAOC,KAAP,EAAcC,QAAd,KAA2B;AAChC;AACA,QAAIC,QAAQ,GAAG,CAAf;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACK,KAAL,CAAWC,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;AAC1C,UAAIJ,IAAI,CAACK,KAAL,CAAWD,CAAX,IAAgB,CAApB,EAAuBD,QAAQ;AAChC;;AACD,QAAIA,QAAQ,KAAK,CAAjB,EAAoB;AAClB;AAEA;AAEA;AACA;AACA;AACA,UAAII,IAAI,GAAGP,IAAI,CAACG,QAAL,CAAcK,MAAd,GAAuBC,IAAvB,GAA8BC,KAAzC;AACAT,MAAAA,KAAK,CAACU,MAAN,CAAaC,IAAb,CAAkBZ,IAAI,CAACa,GAAvB,EAA4Bb,IAAI,CAACc,GAAjC,EAAsCC,GAAtC,GAA4CR,IAA5C;AACAL,MAAAA,QAAQ,CAACU,IAAT,CAAcZ,IAAI,CAACa,GAAnB,EAAwBb,IAAI,CAACc,GAA7B,EAAkCT,KAAlC,CAAwCE,IAAI,GAAG,CAA/C,IAAoD,CAApD,CAVkB,CAYlB;AACA;;AACA,WAAK,IAAIS,GAAT,IAAgBf,KAAK,CAACgB,QAAN,CAAeT,MAAf,EAAhB,EAAyC;AACvC;AACA,YACEQ,GAAG,CAACH,GAAJ,KAAYb,IAAI,CAACa,GAAjB,IACAG,GAAG,CAACF,GAAJ,KAAYd,IAAI,CAACc,GADjB,IAEAE,GAAG,CAACE,KAAJ,KAAclB,IAAI,CAACkB,KAHrB,EAIE;AACA;AACAjB,UAAAA,KAAK,CAACU,MAAN,CAAaQ,MAAb,CAAoBH,GAAG,CAACE,KAAxB,EAA+BF,GAAG,CAACI,IAAnC,EAAyCf,KAAzC,CAA+CE,IAAI,GAAG,CAAtD,IAA2D,CAA3D;AACAL,UAAAA,QAAQ,CAACU,IAAT,CAAcI,GAAG,CAACE,KAAlB,EAAyBF,GAAG,CAACI,IAA7B,EAAmCf,KAAnC,CAAyCE,IAAI,GAAG,CAAhD,IAAqD,CAAC,CAAtD;AACD;AACF;;AAED,UAAIc,GAAG,GAAGpB,KAAK,CAACgB,QAAN,CAAeK,OAAf,CAAuBtB,IAAvB,CAAV;AACAC,MAAAA,KAAK,CAACgB,QAAN,CAAeM,MAAf,CAAsBF,GAAtB,EAA2B,CAA3B,EA5BkB,CA6BlB;;AACA,aAAOnB,QAAP;AACD;;AACD,WAAO,KAAP;AACD;AAzCwB,CAApB","sourcesContent":["//import React from \"react\";\n\n// const NakedSingleComponent = (props) => {\n//   return <h2>naked single</h2>;\n// };\n\nexport const nakedSingle = {\n  name: \"Naked Single\",\n  check: (cell, state, showcase) => {\n    // if this cell has only one suspect...\n    let suspects = 0;\n    for (let i = 0; i < cell.notes.length; i++) {\n      if (cell.notes[i] > 0) suspects++;\n    }\n    if (suspects === 1) {\n      // ...report that suspect's value.\n\n      // TODO: replace this...\n\n      // ...with this\n      // 1) create a copy of state.sudoku\n      // 2) update this cell in the copy cell w new value\n      let soln = cell.suspects.values().next().value;\n      state.sudoku.rows[cell.row][cell.col].val = soln;\n      showcase.rows[cell.row][cell.col].notes[soln - 1] = 1;\n\n      // update affected notes\n      // update affected cell notes\n      for (let aff of state.unsolved.values()) {\n        // TODO: this behavior must be able to manage technique-specific note updates\n        if (\n          aff.row === cell.row ||\n          aff.col === cell.col ||\n          aff.house === cell.house\n        ) {\n          //findSuspects(aff);\n          state.sudoku.houses[aff.house][aff.room].notes[soln - 1] = 0;\n          showcase.rows[aff.house][aff.room].notes[soln - 1] = -1;\n        }\n      }\n\n      let pos = state.unsolved.indexOf(cell);\n      state.unsolved.splice(pos, 1);\n      // 3) return the new sudoku\n      return showcase;\n    }\n    return false;\n  },\n};\n"]},"metadata":{},"sourceType":"module"}