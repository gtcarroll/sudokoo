{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/Gabe/Documents/Projects/sudokoo/src/components/SudokuController.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState } from \"react\";\nimport styled from \"styled-components\";\nimport { colors, animation } from \"../params.js\";\nimport { Sudoku } from \"./sudoku\";\nimport { nakedSingle, hiddenSingle, nakedPair, lockedCandidate, pointingTuple } from \"./techniques\";\nvar solveInterval = false;\nvar isLoaded = false;\nexport const SudokuController = props => {\n  _s();\n\n  const [state, setState] = useState([]);\n  var techniques = [nakedSingle, hiddenSingle, nakedPair, lockedCandidate, pointingTuple]; // input is a 2d array of starting values\n\n  const loadSudoku = input => {\n    console.log(\"Loading Sudoku...\");\n    state.sudoku = {\n      rows: buildEmpty2DArray(),\n      cols: buildEmpty2DArray(),\n      houses: buildEmpty2DArray()\n    };\n    state.isSolved = false;\n    state.unsolved = []; // for every sudoku cell...\n\n    for (let h = 0; h < 9; h++) {\n      for (let r = 0; r < 9; r++) {\n        let y = 3 * Math.floor(h / 3) + Math.floor(r / 3);\n        let x = 3 * (h % 3) + r % 3; // create cell object\n\n        let val = input[y][x];\n        let isUnsolved = !(val >= 1 && val <= 9);\n        var cell = buildNewCell(y, x, h, r, val, !isUnsolved); // store cell in each state object\n\n        state.sudoku.houses[h][r] = cell;\n        state.sudoku.rows[y][x] = cell;\n        state.sudoku.cols[x][y] = cell;\n        if (isUnsolved) state.unsolved.push(cell);\n      }\n    } // for each unsolved cell...\n\n\n    let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n\n    for (let cell of state.unsolved.values()) {\n      let indexes = [cell.row, cell.col, cell.house]; // ...for each axis (row, col, house) this cell belongs to...\n\n      for (let i = 0; i < 3; i++) {\n        // ...for each other cell in that axis...\n        axes[i][indexes[i]].forEach(other => {\n          // ...if the cell's value is set...\n          if (other.val >= 1 && other.val <= 9) {\n            // ...remove it from suspect list.\n            cell.notes[other.val - 1] = 0;\n          }\n        });\n      }\n    }\n\n    isLoaded = true;\n    state.isSolved = false;\n    pushState();\n    console.log(\"...Sudoku Loaded\");\n  };\n\n  const pushState = () => {\n    let localState = {\n      sudoku: state.sudoku,\n      unsolved: state.unsolved,\n      isSolved: state.isSolved\n    };\n    setState(localState);\n  };\n\n  const startSolveInterval = ms => {\n    getNextSolution();\n    solveInterval = setInterval(getNextSolution, ms);\n  };\n\n  const stopSolveInterval = () => {\n    if (solveInterval) {\n      clearInterval(solveInterval);\n      solveInterval = false;\n      pushState();\n    }\n  };\n\n  const getNextSolution = () => {\n    if (!isLoaded) {\n      console.log(\"No sudoku loaded.\");\n      stopSolveInterval();\n      return false;\n    } else if (state.unsolved.length === 0) {\n      console.log(\"Nothing left to solve. Sudoku soln is \" + verifySolution());\n      stopSolveInterval();\n      pushState();\n      return false;\n    } else {\n      let sudokuCopy = copySudoku(state.sudoku); // for each solving technique...\n\n      for (let t = 0; t < techniques.length; t++) {\n        // ...for each unsolved cell...\n        for (let cell of state.unsolved) {\n          // ...if this cell can be solved w this technique...\n          let showcase = techniques[t].check(cell, state, sudokuCopy);\n\n          if (showcase) {\n            // ...report results.\n            console.log(techniques[t].name + \" @ (\" + cell.col + \",\" + cell.row + \")\");\n            pushState();\n            return true;\n          }\n        }\n      }\n\n      console.log(\"No solution was found.\");\n      stopSolveInterval();\n      return false;\n    }\n  };\n\n  const verifySolution = () => {\n    let axisSets = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses]; // for each axis set (rows, cols, houses)...\n\n    for (let s = 0; s < 3; s++) {\n      let axisSet = axisSets[s]; // ...for each axis in that set...\n\n      for (let a = 0; a < 3; a++) {\n        let axis = axisSet[a];\n        let seen = [false, false, false, false, false, false, false, false, false]; // ...for each cell in that axis...\n\n        for (let i = 0; i < 9; i++) {\n          // ...tally all values that are seen...\n          let cell = axis[i];\n          if (cell.val < 1 || cell.val > 9 || seen[cell.val - 1]) return false;else seen[cell.val - 1] = true;\n        } // ...and check that all 9 values are present.\n\n\n        seen.forEach(bool => {\n          if (!bool) {\n            return false;\n          }\n        });\n      }\n    }\n\n    state.isSolved = true;\n    pushState();\n    return true;\n  };\n\n  const buildEmpty2DArray = () => {\n    var result = new Array(9);\n\n    for (let i = 0; i < 9; i++) {\n      result[i] = new Array(9);\n    }\n\n    return result;\n  };\n\n  const buildNewCell = (y, x, h, r, v, p) => {\n    return {\n      row: y,\n      col: x,\n      house: h,\n      room: r,\n      val: v,\n      preset: p,\n      notes: [1, 1, 1, 1, 1, 1, 1, 1, 1]\n    };\n  };\n\n  const copySudoku = sudoku => {\n    let copy = {\n      rows: buildEmpty2DArray(),\n      cols: buildEmpty2DArray(),\n      houses: buildEmpty2DArray()\n    };\n\n    for (let h = 0; h < 9; h++) {\n      for (let r = 0; r < 9; r++) {\n        let y = 3 * Math.floor(h / 3) + Math.floor(r / 3);\n        let x = 3 * (h % 3) + r % 3; // create cell object\n\n        var cell = copyCell(sudoku.houses[h][r]); // store cell in each state object\n\n        copy.houses[h][r] = cell;\n        copy.rows[y][x] = cell;\n        copy.cols[x][y] = cell;\n      }\n    }\n\n    return copy;\n  };\n\n  const copyCell = cell => {\n    return {\n      row: cell.row,\n      col: cell.col,\n      house: cell.house,\n      room: cell.room,\n      val: cell.val,\n      preset: cell.preset,\n      notes: [...cell.notes]\n    };\n  };\n\n  return /*#__PURE__*/_jsxDEV(StyledDiv, {\n    children: [/*#__PURE__*/_jsxDEV(Sudoku, {\n      sudoku: state.sudoku,\n      isSolved: state.isSolved\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Controls, {\n      children: !isLoaded ? /*#__PURE__*/_jsxDEV(Button, {\n        onClick: () => loadSudoku(pointingTuple.test),\n        children: \"load\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 234,\n        columnNumber: 11\n      }, this) : state.isSolved ? /*#__PURE__*/_jsxDEV(Button, {\n        onClick: () => loadSudoku(pointingTuple.test),\n        children: \"reset\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 236,\n        columnNumber: 11\n      }, this) : solveInterval ? /*#__PURE__*/_jsxDEV(Controls, {\n        children: [/*#__PURE__*/_jsxDEV(Button, {\n          onClick: () => stopSolveInterval(),\n          children: \"stop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 239,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          onClick: () => getNextSolution(),\n          children: \"next\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 240,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 238,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(Controls, {\n        children: [/*#__PURE__*/_jsxDEV(Button, {\n          onClick: () => startSolveInterval(animation.delay),\n          children: \"auto-solve\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 244,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          onClick: () => getNextSolution(),\n          children: \"next\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 247,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 243,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 232,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 230,\n    columnNumber: 5\n  }, this);\n};\n\n_s(SudokuController, \"yua82o5JV2p+bdzgVd8naWBubMo=\");\n\n_c = SudokuController;\nconst StyledDiv = styled.div`\n  display: grid;\n  grid-template-rows: min(80vw, 80vh) 1fr;\n  grid-template-columns: 1fr;\n  grid-gap: 2rem;\n\n  width: min(80vw, 80vh);\n  height: 100%;\n`;\n_c2 = StyledDiv;\nconst Controls = styled.div`\n  display: flex;\n  flex-direction: row;\n  flex: 1;\n  gap: 2em;\n\n  width: 100%;\n`;\n_c3 = Controls;\nconst Button = styled.button`\n  color: ${colors.sudokuBorder};\n  background-color: transparent;\n  border: 2px solid ${colors.sudokuBorder};\n  border-radius: 1em;\n\n  width: 100%;\n  padding: 0.2em;\n  font-size: 24px;\n  transition: all 0.3s ease;\n\n  &:hover {\n    background-color: ${colors.sudokuBorder};\n    color: ${colors.appBG};\n    transform: scale(1.05);\n  }\n  &:active {\n    transition: all 0.05 ease-in;\n    background-color: ${colors.sudokuBG};\n    transform: scale(1.025);\n    color: ${colors.sudokuBorder};\n  }\n`;\n_c4 = Button;\n\nvar _c, _c2, _c3, _c4;\n\n$RefreshReg$(_c, \"SudokuController\");\n$RefreshReg$(_c2, \"StyledDiv\");\n$RefreshReg$(_c3, \"Controls\");\n$RefreshReg$(_c4, \"Button\");","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/SudokuController.js"],"names":["React","useState","styled","colors","animation","Sudoku","nakedSingle","hiddenSingle","nakedPair","lockedCandidate","pointingTuple","solveInterval","isLoaded","SudokuController","props","state","setState","techniques","loadSudoku","input","console","log","sudoku","rows","buildEmpty2DArray","cols","houses","isSolved","unsolved","h","r","y","Math","floor","x","val","isUnsolved","cell","buildNewCell","push","axes","values","indexes","row","col","house","i","forEach","other","notes","pushState","localState","startSolveInterval","ms","getNextSolution","setInterval","stopSolveInterval","clearInterval","length","verifySolution","sudokuCopy","copySudoku","t","showcase","check","name","axisSets","s","axisSet","a","axis","seen","bool","result","Array","v","p","room","preset","copy","copyCell","test","delay","StyledDiv","div","Controls","Button","button","sudokuBorder","appBG","sudokuBG"],"mappings":"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","sourcesContent":["import React, { useState } from \"react\";\nimport styled from \"styled-components\";\nimport { colors, animation } from \"../params.js\";\nimport { Sudoku } from \"./sudoku\";\nimport {\n  nakedSingle,\n  hiddenSingle,\n  nakedPair,\n  lockedCandidate,\n  pointingTuple,\n} from \"./techniques\";\n\nvar solveInterval = false;\nvar isLoaded = false;\n\nexport const SudokuController = (props) => {\n  const [state, setState] = useState([]);\n  var techniques = [\n    nakedSingle,\n    hiddenSingle,\n    nakedPair,\n    lockedCandidate,\n    pointingTuple,\n  ];\n\n  // input is a 2d array of starting values\n  const loadSudoku = (input) => {\n    console.log(\"Loading Sudoku...\");\n\n    state.sudoku = {\n      rows: buildEmpty2DArray(),\n      cols: buildEmpty2DArray(),\n      houses: buildEmpty2DArray(),\n    };\n    state.isSolved = false;\n    state.unsolved = [];\n\n    // for every sudoku cell...\n    for (let h = 0; h < 9; h++) {\n      for (let r = 0; r < 9; r++) {\n        let y = 3 * Math.floor(h / 3) + Math.floor(r / 3);\n        let x = 3 * (h % 3) + (r % 3);\n\n        // create cell object\n        let val = input[y][x];\n        let isUnsolved = !(val >= 1 && val <= 9);\n        var cell = buildNewCell(y, x, h, r, val, !isUnsolved);\n        // store cell in each state object\n        state.sudoku.houses[h][r] = cell;\n        state.sudoku.rows[y][x] = cell;\n        state.sudoku.cols[x][y] = cell;\n        if (isUnsolved) state.unsolved.push(cell);\n      }\n    }\n\n    // for each unsolved cell...\n    let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    for (let cell of state.unsolved.values()) {\n      let indexes = [cell.row, cell.col, cell.house];\n      // ...for each axis (row, col, house) this cell belongs to...\n      for (let i = 0; i < 3; i++) {\n        // ...for each other cell in that axis...\n        axes[i][indexes[i]].forEach((other) => {\n          // ...if the cell's value is set...\n          if (other.val >= 1 && other.val <= 9) {\n            // ...remove it from suspect list.\n            cell.notes[other.val - 1] = 0;\n          }\n        });\n      }\n    }\n    isLoaded = true;\n    state.isSolved = false;\n    pushState();\n\n    console.log(\"...Sudoku Loaded\");\n  };\n\n  const pushState = () => {\n    let localState = {\n      sudoku: state.sudoku,\n      unsolved: state.unsolved,\n      isSolved: state.isSolved,\n    };\n    setState(localState);\n  };\n\n  const startSolveInterval = (ms) => {\n    getNextSolution();\n    solveInterval = setInterval(getNextSolution, ms);\n  };\n\n  const stopSolveInterval = () => {\n    if (solveInterval) {\n      clearInterval(solveInterval);\n      solveInterval = false;\n      pushState();\n    }\n  };\n\n  const getNextSolution = () => {\n    if (!isLoaded) {\n      console.log(\"No sudoku loaded.\");\n      stopSolveInterval();\n      return false;\n    } else if (state.unsolved.length === 0) {\n      console.log(\"Nothing left to solve. Sudoku soln is \" + verifySolution());\n      stopSolveInterval();\n      pushState();\n      return false;\n    } else {\n      let sudokuCopy = copySudoku(state.sudoku);\n      // for each solving technique...\n      for (let t = 0; t < techniques.length; t++) {\n        // ...for each unsolved cell...\n        for (let cell of state.unsolved) {\n          // ...if this cell can be solved w this technique...\n          let showcase = techniques[t].check(cell, state, sudokuCopy);\n          if (showcase) {\n            // ...report results.\n            console.log(\n              techniques[t].name + \" @ (\" + cell.col + \",\" + cell.row + \")\"\n            );\n            pushState();\n            return true;\n          }\n        }\n      }\n      console.log(\"No solution was found.\");\n      stopSolveInterval();\n      return false;\n    }\n  };\n\n  const verifySolution = () => {\n    let axisSets = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    // for each axis set (rows, cols, houses)...\n    for (let s = 0; s < 3; s++) {\n      let axisSet = axisSets[s];\n      // ...for each axis in that set...\n      for (let a = 0; a < 3; a++) {\n        let axis = axisSet[a];\n        let seen = [\n          false,\n          false,\n          false,\n          false,\n          false,\n          false,\n          false,\n          false,\n          false,\n        ];\n        // ...for each cell in that axis...\n        for (let i = 0; i < 9; i++) {\n          // ...tally all values that are seen...\n          let cell = axis[i];\n          if (cell.val < 1 || cell.val > 9 || seen[cell.val - 1]) return false;\n          else seen[cell.val - 1] = true;\n        }\n        // ...and check that all 9 values are present.\n        seen.forEach((bool) => {\n          if (!bool) {\n            return false;\n          }\n        });\n      }\n    }\n    state.isSolved = true;\n    pushState();\n    return true;\n  };\n\n  const buildEmpty2DArray = () => {\n    var result = new Array(9);\n    for (let i = 0; i < 9; i++) {\n      result[i] = new Array(9);\n    }\n    return result;\n  };\n\n  const buildNewCell = (y, x, h, r, v, p) => {\n    return {\n      row: y,\n      col: x,\n      house: h,\n      room: r,\n      val: v,\n      preset: p,\n      notes: [1, 1, 1, 1, 1, 1, 1, 1, 1],\n    };\n  };\n\n  const copySudoku = (sudoku) => {\n    let copy = {\n      rows: buildEmpty2DArray(),\n      cols: buildEmpty2DArray(),\n      houses: buildEmpty2DArray(),\n    };\n    for (let h = 0; h < 9; h++) {\n      for (let r = 0; r < 9; r++) {\n        let y = 3 * Math.floor(h / 3) + Math.floor(r / 3);\n        let x = 3 * (h % 3) + (r % 3);\n\n        // create cell object\n        var cell = copyCell(sudoku.houses[h][r]);\n\n        // store cell in each state object\n        copy.houses[h][r] = cell;\n        copy.rows[y][x] = cell;\n        copy.cols[x][y] = cell;\n      }\n    }\n    return copy;\n  };\n\n  const copyCell = (cell) => {\n    return {\n      row: cell.row,\n      col: cell.col,\n      house: cell.house,\n      room: cell.room,\n      val: cell.val,\n      preset: cell.preset,\n      notes: [...cell.notes],\n    };\n  };\n\n  return (\n    <StyledDiv>\n      <Sudoku sudoku={state.sudoku} isSolved={state.isSolved}></Sudoku>\n      <Controls>\n        {!isLoaded ? (\n          <Button onClick={() => loadSudoku(pointingTuple.test)}>load</Button>\n        ) : state.isSolved ? (\n          <Button onClick={() => loadSudoku(pointingTuple.test)}>reset</Button>\n        ) : solveInterval ? (\n          <Controls>\n            <Button onClick={() => stopSolveInterval()}>stop</Button>\n            <Button onClick={() => getNextSolution()}>next</Button>\n          </Controls>\n        ) : (\n          <Controls>\n            <Button onClick={() => startSolveInterval(animation.delay)}>\n              auto-solve\n            </Button>\n            <Button onClick={() => getNextSolution()}>next</Button>\n          </Controls>\n        )}\n      </Controls>\n    </StyledDiv>\n  );\n};\n\nconst StyledDiv = styled.div`\n  display: grid;\n  grid-template-rows: min(80vw, 80vh) 1fr;\n  grid-template-columns: 1fr;\n  grid-gap: 2rem;\n\n  width: min(80vw, 80vh);\n  height: 100%;\n`;\n\nconst Controls = styled.div`\n  display: flex;\n  flex-direction: row;\n  flex: 1;\n  gap: 2em;\n\n  width: 100%;\n`;\n\nconst Button = styled.button`\n  color: ${colors.sudokuBorder};\n  background-color: transparent;\n  border: 2px solid ${colors.sudokuBorder};\n  border-radius: 1em;\n\n  width: 100%;\n  padding: 0.2em;\n  font-size: 24px;\n  transition: all 0.3s ease;\n\n  &:hover {\n    background-color: ${colors.sudokuBorder};\n    color: ${colors.appBG};\n    transform: scale(1.05);\n  }\n  &:active {\n    transition: all 0.05 ease-in;\n    background-color: ${colors.sudokuBG};\n    transform: scale(1.025);\n    color: ${colors.sudokuBorder};\n  }\n`;\n"]},"metadata":{},"sourceType":"module"}