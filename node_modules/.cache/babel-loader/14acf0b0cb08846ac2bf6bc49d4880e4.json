{"ast":null,"code":"//import React from \"react\";\n// const PointingTuple = (props) => {\n//   return <h2>pointing tuple</h2>;\n// };\nexport const pointingTuple = {\n  name: \"Pointing Tuple\",\n  test: [[0, 0, 0, 0, 0, 0, 3, 9, 5], [5, 0, 0, 0, 7, 0, 0, 2, 0], [0, 0, 0, 6, 0, 5, 7, 1, 0], [0, 0, 0, 5, 0, 4, 0, 6, 0], [0, 0, 0, 7, 0, 3, 0, 0, 0], [0, 4, 5, 0, 0, 0, 0, 0, 0], [0, 1, 3, 0, 5, 0, 0, 7, 0], [0, 5, 0, 0, 8, 7, 0, 0, 2], [2, 0, 7, 0, 0, 0, 0, 0, 0]],\n  check: (cell, state, showcase) => {\n    let axes = [state.sudoku.rows, state.sudoku.cols];\n    let cellIndexes = [cell.row, cell.col];\n    let wasUpdated = false; // for each axis this cell belongs to...\n\n    for (let a = 0; a < 2; a++) {\n      let unseen = [];\n\n      for (let i = 0; i < 9; i++) if (cell.notes[i] > 0) unseen.push(i);\n\n      let axis = axes[a][cellIndexes[a]]; // ...for each other cell in this cell's house...\n\n      for (let r = 0; r < 9; r++) {\n        let other = state.sudoku.houses[cell.house][r];\n        let otherIndexes = [other.row, other.col]; // ...if that other cell is not in the same axis...\n\n        if (otherIndexes[a] !== cellIndexes[a]) {\n          // ...remove its suspects from the unseen list...\n          for (let n = 0; n < 9; n++) {\n            if (other.val <= 0 && other.notes[n] > 0 && unseen.includes(n)) {\n              unseen.splice(unseen.indexOf(n), 1);\n            }\n          }\n        }\n      } // ...if there are any unseen suspects left...\n\n\n      if (unseen.length > 0) {\n        let soln = unseen[0] + 1;\n        let notOnlyOne = false;\n\n        for (let i = 0; i < 9; i++) {\n          let roomie = axis[i];\n          notOnlyOne |= roomie.house !== cell.house && roomie.val <= 0 && roomie.notes[soln - 1] > 0 && unseen.includes(soln - 1);\n        } // ...if this cell is not the only one in its axis and house w soln in suspects...\n\n\n        if (notOnlyOne) {\n          // ...for each other unsolved cell in the same house...\n          for (let r = 0; r < 9; r++) {// if (r !== cell.room) {\n            //   let aff = state.sudoku.houses[cell.house][r];\n            //   let affIndexes = [aff.row, aff.col];\n            //   // ...if aff would be affected and is not in the same axis as cell...\n            //   if (\n            //     aff.val <= 0 &&\n            //     aff.notes[soln - 1] > 0 &&\n            //     aff.house !== indexes[a]\n            //   ) {\n            //     wasUpdated = true;\n            //     // ...remove the soln from that cell's suspects.\n            //     aff.notes[soln - 1] = 0;\n            //     // ...cross out the soln in the showcase.\n            //     showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n          }\n\n          for (let i = 0; i < 9; i++) {\n            let aff = axis[i];\n            let affIndexes = [aff.row, aff.col]; // ...if aff would be affected and is in the same axis as cell...\n\n            if (aff.val <= 0 && aff.notes[soln - 1] > 0 && affIndexes[a] === cellIndexes[a]) {\n              if (aff.house !== cell.house) {\n                wasUpdated = true; // ...remove the soln val in state.\n\n                aff.notes[soln - 1] = 0; // ...remove the soln val in the showcase.\n\n                showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n              }\n            }\n          }\n\n          if (wasUpdated) {\n            for (let i = 0; i < 9; i++) {\n              let aff = axis[i];\n              let affIndexes = [aff.row, aff.col]; // ...if aff would be affected and is in the same axis as cell...\n\n              if (aff.val <= 0 && aff.notes[soln - 1] > 0 && affIndexes[a] === cellIndexes[a]) {\n                if (aff.house === cell.house) {\n                  wasUpdated = true; // ...highlight the soln val in state.\n\n                  aff.notes[soln - 1] = 3; // ...highlight the soln val in the showcase.\n\n                  showcase.houses[aff.house][aff.room].notes[soln - 1] = 2;\n                }\n              }\n            }\n          }\n        }\n      } // ...if updates to sudoku state were made, return them\n\n\n      if (wasUpdated) return showcase;\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/PointingTuple.js"],"names":["pointingTuple","name","test","check","cell","state","showcase","axes","sudoku","rows","cols","cellIndexes","row","col","wasUpdated","a","unseen","i","notes","push","axis","r","other","houses","house","otherIndexes","n","val","includes","splice","indexOf","length","soln","notOnlyOne","roomie","aff","affIndexes","room"],"mappings":"AAAA;AAEA;AACA;AACA;AAEA,OAAO,MAAMA,aAAa,GAAG;AAC3BC,EAAAA,IAAI,EAAE,gBADqB;AAE3BC,EAAAA,IAAI,EAAE,CACJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CADI,EAEJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAFI,EAGJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAHI,EAIJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAJI,EAKJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CALI,EAMJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CANI,EAOJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAPI,EAQJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CARI,EASJ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CATI,CAFqB;AAa3BC,EAAAA,KAAK,EAAE,CAACC,IAAD,EAAOC,KAAP,EAAcC,QAAd,KAA2B;AAChC,QAAIC,IAAI,GAAG,CAACF,KAAK,CAACG,MAAN,CAAaC,IAAd,EAAoBJ,KAAK,CAACG,MAAN,CAAaE,IAAjC,CAAX;AACA,QAAIC,WAAW,GAAG,CAACP,IAAI,CAACQ,GAAN,EAAWR,IAAI,CAACS,GAAhB,CAAlB;AACA,QAAIC,UAAU,GAAG,KAAjB,CAHgC,CAKhC;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,UAAIC,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B,IAAIb,IAAI,CAACc,KAAL,CAAWD,CAAX,IAAgB,CAApB,EAAuBD,MAAM,CAACG,IAAP,CAAYF,CAAZ;;AACnD,UAAIG,IAAI,GAAGb,IAAI,CAACQ,CAAD,CAAJ,CAAQJ,WAAW,CAACI,CAAD,CAAnB,CAAX,CAH0B,CAK1B;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAIC,KAAK,GAAGjB,KAAK,CAACG,MAAN,CAAae,MAAb,CAAoBnB,IAAI,CAACoB,KAAzB,EAAgCH,CAAhC,CAAZ;AACA,YAAII,YAAY,GAAG,CAACH,KAAK,CAACV,GAAP,EAAYU,KAAK,CAACT,GAAlB,CAAnB,CAF0B,CAI1B;;AACA,YAAIY,YAAY,CAACV,CAAD,CAAZ,KAAoBJ,WAAW,CAACI,CAAD,CAAnC,EAAwC;AACtC;AACA,eAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,gBAAIJ,KAAK,CAACK,GAAN,IAAa,CAAb,IAAkBL,KAAK,CAACJ,KAAN,CAAYQ,CAAZ,IAAiB,CAAnC,IAAwCV,MAAM,CAACY,QAAP,CAAgBF,CAAhB,CAA5C,EAAgE;AAC9DV,cAAAA,MAAM,CAACa,MAAP,CAAcb,MAAM,CAACc,OAAP,CAAeJ,CAAf,CAAd,EAAiC,CAAjC;AACD;AACF;AACF;AACF,OAnByB,CAqB1B;;;AACA,UAAIV,MAAM,CAACe,MAAP,GAAgB,CAApB,EAAuB;AACrB,YAAIC,IAAI,GAAGhB,MAAM,CAAC,CAAD,CAAN,GAAY,CAAvB;AACA,YAAIiB,UAAU,GAAG,KAAjB;;AACA,aAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,cAAIiB,MAAM,GAAGd,IAAI,CAACH,CAAD,CAAjB;AACAgB,UAAAA,UAAU,IACRC,MAAM,CAACV,KAAP,KAAiBpB,IAAI,CAACoB,KAAtB,IACAU,MAAM,CAACP,GAAP,IAAc,CADd,IAEAO,MAAM,CAAChB,KAAP,CAAac,IAAI,GAAG,CAApB,IAAyB,CAFzB,IAGAhB,MAAM,CAACY,QAAP,CAAgBI,IAAI,GAAG,CAAvB,CAJF;AAKD,SAVoB,CAWrB;;;AACA,YAAIC,UAAJ,EAAgB;AACd;AACA,eAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B,CAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AAED,eAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,gBAAIkB,GAAG,GAAGf,IAAI,CAACH,CAAD,CAAd;AACA,gBAAImB,UAAU,GAAG,CAACD,GAAG,CAACvB,GAAL,EAAUuB,GAAG,CAACtB,GAAd,CAAjB,CAF0B,CAI1B;;AACA,gBACEsB,GAAG,CAACR,GAAJ,IAAW,CAAX,IACAQ,GAAG,CAACjB,KAAJ,CAAUc,IAAI,GAAG,CAAjB,IAAsB,CADtB,IAEAI,UAAU,CAACrB,CAAD,CAAV,KAAkBJ,WAAW,CAACI,CAAD,CAH/B,EAIE;AACA,kBAAIoB,GAAG,CAACX,KAAJ,KAAcpB,IAAI,CAACoB,KAAvB,EAA8B;AAC5BV,gBAAAA,UAAU,GAAG,IAAb,CAD4B,CAE5B;;AACAqB,gBAAAA,GAAG,CAACjB,KAAJ,CAAUc,IAAI,GAAG,CAAjB,IAAsB,CAAtB,CAH4B,CAI5B;;AACA1B,gBAAAA,QAAQ,CAACiB,MAAT,CAAgBY,GAAG,CAACX,KAApB,EAA2BW,GAAG,CAACE,IAA/B,EAAqCnB,KAArC,CAA2Cc,IAAI,GAAG,CAAlD,IAAuD,CAAC,CAAxD;AACD;AACF;AACF;;AAED,cAAIlB,UAAJ,EAAgB;AACd,iBAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,kBAAIkB,GAAG,GAAGf,IAAI,CAACH,CAAD,CAAd;AACA,kBAAImB,UAAU,GAAG,CAACD,GAAG,CAACvB,GAAL,EAAUuB,GAAG,CAACtB,GAAd,CAAjB,CAF0B,CAI1B;;AACA,kBACEsB,GAAG,CAACR,GAAJ,IAAW,CAAX,IACAQ,GAAG,CAACjB,KAAJ,CAAUc,IAAI,GAAG,CAAjB,IAAsB,CADtB,IAEAI,UAAU,CAACrB,CAAD,CAAV,KAAkBJ,WAAW,CAACI,CAAD,CAH/B,EAIE;AACA,oBAAIoB,GAAG,CAACX,KAAJ,KAAcpB,IAAI,CAACoB,KAAvB,EAA8B;AAC5BV,kBAAAA,UAAU,GAAG,IAAb,CAD4B,CAE5B;;AACAqB,kBAAAA,GAAG,CAACjB,KAAJ,CAAUc,IAAI,GAAG,CAAjB,IAAsB,CAAtB,CAH4B,CAI5B;;AACA1B,kBAAAA,QAAQ,CAACiB,MAAT,CAAgBY,GAAG,CAACX,KAApB,EAA2BW,GAAG,CAACE,IAA/B,EAAqCnB,KAArC,CAA2Cc,IAAI,GAAG,CAAlD,IAAuD,CAAvD;AACD;AACF;AACF;AACF;AACF;AACF,OA/FyB,CAgG1B;;;AACA,UAAIlB,UAAJ,EAAgB,OAAOR,QAAP;AACjB;;AAED,WAAO,KAAP;AACD;AAxH0B,CAAtB","sourcesContent":["//import React from \"react\";\n\n// const PointingTuple = (props) => {\n//   return <h2>pointing tuple</h2>;\n// };\n\nexport const pointingTuple = {\n  name: \"Pointing Tuple\",\n  test: [\n    [0, 0, 0, 0, 0, 0, 3, 9, 5],\n    [5, 0, 0, 0, 7, 0, 0, 2, 0],\n    [0, 0, 0, 6, 0, 5, 7, 1, 0],\n    [0, 0, 0, 5, 0, 4, 0, 6, 0],\n    [0, 0, 0, 7, 0, 3, 0, 0, 0],\n    [0, 4, 5, 0, 0, 0, 0, 0, 0],\n    [0, 1, 3, 0, 5, 0, 0, 7, 0],\n    [0, 5, 0, 0, 8, 7, 0, 0, 2],\n    [2, 0, 7, 0, 0, 0, 0, 0, 0],\n  ],\n  check: (cell, state, showcase) => {\n    let axes = [state.sudoku.rows, state.sudoku.cols];\n    let cellIndexes = [cell.row, cell.col];\n    let wasUpdated = false;\n\n    // for each axis this cell belongs to...\n    for (let a = 0; a < 2; a++) {\n      let unseen = [];\n      for (let i = 0; i < 9; i++) if (cell.notes[i] > 0) unseen.push(i);\n      let axis = axes[a][cellIndexes[a]];\n\n      // ...for each other cell in this cell's house...\n      for (let r = 0; r < 9; r++) {\n        let other = state.sudoku.houses[cell.house][r];\n        let otherIndexes = [other.row, other.col];\n\n        // ...if that other cell is not in the same axis...\n        if (otherIndexes[a] !== cellIndexes[a]) {\n          // ...remove its suspects from the unseen list...\n          for (let n = 0; n < 9; n++) {\n            if (other.val <= 0 && other.notes[n] > 0 && unseen.includes(n)) {\n              unseen.splice(unseen.indexOf(n), 1);\n            }\n          }\n        }\n      }\n\n      // ...if there are any unseen suspects left...\n      if (unseen.length > 0) {\n        let soln = unseen[0] + 1;\n        let notOnlyOne = false;\n        for (let i = 0; i < 9; i++) {\n          let roomie = axis[i];\n          notOnlyOne |=\n            roomie.house !== cell.house &&\n            roomie.val <= 0 &&\n            roomie.notes[soln - 1] > 0 &&\n            unseen.includes(soln - 1);\n        }\n        // ...if this cell is not the only one in its axis and house w soln in suspects...\n        if (notOnlyOne) {\n          // ...for each other unsolved cell in the same house...\n          for (let r = 0; r < 9; r++) {\n            // if (r !== cell.room) {\n            //   let aff = state.sudoku.houses[cell.house][r];\n            //   let affIndexes = [aff.row, aff.col];\n            //   // ...if aff would be affected and is not in the same axis as cell...\n            //   if (\n            //     aff.val <= 0 &&\n            //     aff.notes[soln - 1] > 0 &&\n            //     aff.house !== indexes[a]\n            //   ) {\n            //     wasUpdated = true;\n            //     // ...remove the soln from that cell's suspects.\n            //     aff.notes[soln - 1] = 0;\n            //     // ...cross out the soln in the showcase.\n            //     showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n          }\n\n          for (let i = 0; i < 9; i++) {\n            let aff = axis[i];\n            let affIndexes = [aff.row, aff.col];\n\n            // ...if aff would be affected and is in the same axis as cell...\n            if (\n              aff.val <= 0 &&\n              aff.notes[soln - 1] > 0 &&\n              affIndexes[a] === cellIndexes[a]\n            ) {\n              if (aff.house !== cell.house) {\n                wasUpdated = true;\n                // ...remove the soln val in state.\n                aff.notes[soln - 1] = 0;\n                // ...remove the soln val in the showcase.\n                showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n              }\n            }\n          }\n\n          if (wasUpdated) {\n            for (let i = 0; i < 9; i++) {\n              let aff = axis[i];\n              let affIndexes = [aff.row, aff.col];\n\n              // ...if aff would be affected and is in the same axis as cell...\n              if (\n                aff.val <= 0 &&\n                aff.notes[soln - 1] > 0 &&\n                affIndexes[a] === cellIndexes[a]\n              ) {\n                if (aff.house === cell.house) {\n                  wasUpdated = true;\n                  // ...highlight the soln val in state.\n                  aff.notes[soln - 1] = 3;\n                  // ...highlight the soln val in the showcase.\n                  showcase.houses[aff.house][aff.room].notes[soln - 1] = 2;\n                }\n              }\n            }\n          }\n        }\n      }\n      // ...if updates to sudoku state were made, return them\n      if (wasUpdated) return showcase;\n    }\n\n    return false;\n  },\n};\n"]},"metadata":{},"sourceType":"module"}