{"ast":null,"code":"//import React from \"react\";\n// const HiddenSingleComponent = (props) => {\n//   return <h2>naked single</h2>;\n// };\nexport const hiddenSingle = {\n  name: \"Hidden Single\",\n  check: (cell, state) => {\n    const isSameCell = (c1, c2) => {\n      return c1.row === c2.row && c1.col === c2.col;\n    };\n\n    let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    let indexes = [cell.row, cell.col, cell.house];\n\n    for (let a = 0; a < 3; a++) {\n      let axis = axes[a][indexes[a]];\n      let unseen = Array.from(cell.suspects);\n\n      for (let i = 0; i < 9; i++) {\n        let other = axis[i];\n\n        if (other.val > 0) {\n          unseen = unseen.filter(e => e !== other.val);\n        }\n      }\n\n      if (unseen.length > 0) {\n        console.log(\"WHOA\");\n        return unseen[0];\n      }\n    } // TODO: update data structure to allow for clean loops over each axis\n    // for each axis this cell is in\n    // let axes = [state.rows, state.cols, state.houses];\n    // let indexes = [cell.row, cell.col, cell.house];\n    // for (let a = 0; a < 3; a++) {\n    //   let axis = axes[a][indexes[a]];\n    //   for (let i = 0; i < 9; i++) {\n    //     if (state.unsolved.has())\n    //   }\n    // }\n    // let unseen = Array.from(cell.suspects);\n    //   create list of seen values\n    //   for each cell\n    //     if value is valid\n    //       add value to seen\n    // // Hidden Single check\n    // // identify each cell's suspect values\n    // let axes = [state.rows, state.cols, state.houses];\n    // let indexes = [cell.row, cell.col, cell.house];\n    // let unseen = Array.from(cell.suspects);\n    // for (let a = 0; a < 3; a++) {\n    //   let index = indexes[a];\n    //   let axis = axes[a][index];\n    //   console.log(axis);\n    //   for (let other of axis) {\n    //   }\n    //   state.unsolved.forEach((other) => {\n    //     if (\n    //       (cell.row === other.row ||\n    //         cell.col === other.col ||\n    //         cell.house === other.house) &&\n    //       !isSameCell(cell, other)\n    //     ) {\n    //       other.suspects.forEach((val) => {\n    //         //console.log(\"DEBUG\" + val);\n    //         unseen = unseen.filter((e) => e !== val);\n    //       });\n    //     }\n    //   });\n    //   if (unseen.length > 0) {\n    //     console.log(\"WHOA\");\n    //     return unseen[0];\n    //   }\n    // }\n    // TODO: create function that runs passed fxn on row, col, house to reduce code duplication\n    // TODO: fix this total fustercluck\n    //for (let i = 0; i < state.unsolved.length && i < 81; i++) {\n    // let target = cell;\n    // //let unseen = Array.from(target.suspects);\n    // state.unsolved.forEach((cell) => {\n    //   if (cell.row === target.row && !isSameCell(target, cell)) {\n    //     cell.suspects.forEach((val) => {\n    //       //console.log(\"DEBUG\" + val);\n    //       unseen = unseen.filter((e) => e !== val);\n    //     });\n    //   }\n    // });\n    // if (unseen.length > 0) {\n    //   return unseen[0];\n    //   //   target = state.unsolved.splice(i, 1)[0];\n    //   //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    // }\n    // unseen = Array.from(target.suspects);\n    // //console.log(unseen);\n    // state.unsolved.forEach((cell) => {\n    //   if (cell.col === target.col && !isSameCell(target, cell)) {\n    //     cell.suspects.forEach((val) => {\n    //       //console.log(\"DEBUG\" + val);\n    //       unseen = unseen.filter((e) => e !== val);\n    //     });\n    //   }\n    // });\n    // if (unseen.length > 0) {\n    //   return unseen[0];\n    //   //   target = state.unsolved.splice(i, 1)[0];\n    //   //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    // }\n    // unseen = Array.from(target.suspects);\n    // //console.log(unseen);\n    // state.unsolved.forEach((cell) => {\n    //   if (cell.house === target.house && !isSameCell(target, cell)) {\n    //     cell.suspects.forEach((val) => {\n    //       //console.log(\"DEBUG\" + val);\n    //       unseen = unseen.filter((e) => e !== val);\n    //     });\n    //   }\n    // });\n    // if (unseen.length > 0) {\n    //   return unseen[0];\n    //   //   target = state.unsolved.splice(i, 1)[0];\n    //   //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    // }\n\n\n    return 0; //}\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/HiddenSingle.js"],"names":["hiddenSingle","name","check","cell","state","isSameCell","c1","c2","row","col","axes","sudoku","rows","cols","houses","indexes","house","a","axis","unseen","Array","from","suspects","i","other","val","filter","e","length","console","log"],"mappings":"AAAA;AAEA;AACA;AACA;AAEA,OAAO,MAAMA,YAAY,GAAG;AAC1BC,EAAAA,IAAI,EAAE,eADoB;AAE1BC,EAAAA,KAAK,EAAE,CAACC,IAAD,EAAOC,KAAP,KAAiB;AACtB,UAAMC,UAAU,GAAG,CAACC,EAAD,EAAKC,EAAL,KAAY;AAC7B,aAAOD,EAAE,CAACE,GAAH,KAAWD,EAAE,CAACC,GAAd,IAAqBF,EAAE,CAACG,GAAH,KAAWF,EAAE,CAACE,GAA1C;AACD,KAFD;;AAIA,QAAIC,IAAI,GAAG,CAACN,KAAK,CAACO,MAAN,CAAaC,IAAd,EAAoBR,KAAK,CAACO,MAAN,CAAaE,IAAjC,EAAuCT,KAAK,CAACO,MAAN,CAAaG,MAApD,CAAX;AACA,QAAIC,OAAO,GAAG,CAACZ,IAAI,CAACK,GAAN,EAAWL,IAAI,CAACM,GAAhB,EAAqBN,IAAI,CAACa,KAA1B,CAAd;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,UAAIC,IAAI,GAAGR,IAAI,CAACO,CAAD,CAAJ,CAAQF,OAAO,CAACE,CAAD,CAAf,CAAX;AACA,UAAIE,MAAM,GAAGC,KAAK,CAACC,IAAN,CAAWlB,IAAI,CAACmB,QAAhB,CAAb;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAIC,KAAK,GAAGN,IAAI,CAACK,CAAD,CAAhB;;AACA,YAAIC,KAAK,CAACC,GAAN,GAAY,CAAhB,EAAmB;AACjBN,UAAAA,MAAM,GAAGA,MAAM,CAACO,MAAP,CAAeC,CAAD,IAAOA,CAAC,KAAKH,KAAK,CAACC,GAAjC,CAAT;AACD;AACF;;AACD,UAAIN,MAAM,CAACS,MAAP,GAAgB,CAApB,EAAuB;AACrBC,QAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ;AACA,eAAOX,MAAM,CAAC,CAAD,CAAb;AACD;AACF,KApBqB,CAsBtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,WAAO,CAAP,CAzHsB,CA0HtB;AACD;AA7HyB,CAArB","sourcesContent":["//import React from \"react\";\n\n// const HiddenSingleComponent = (props) => {\n//   return <h2>naked single</h2>;\n// };\n\nexport const hiddenSingle = {\n  name: \"Hidden Single\",\n  check: (cell, state) => {\n    const isSameCell = (c1, c2) => {\n      return c1.row === c2.row && c1.col === c2.col;\n    };\n\n    let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    let indexes = [cell.row, cell.col, cell.house];\n    for (let a = 0; a < 3; a++) {\n      let axis = axes[a][indexes[a]];\n      let unseen = Array.from(cell.suspects);\n      for (let i = 0; i < 9; i++) {\n        let other = axis[i];\n        if (other.val > 0) {\n          unseen = unseen.filter((e) => e !== other.val);\n        }\n      }\n      if (unseen.length > 0) {\n        console.log(\"WHOA\");\n        return unseen[0];\n      }\n    }\n\n    // TODO: update data structure to allow for clean loops over each axis\n\n    // for each axis this cell is in\n    // let axes = [state.rows, state.cols, state.houses];\n    // let indexes = [cell.row, cell.col, cell.house];\n    // for (let a = 0; a < 3; a++) {\n    //   let axis = axes[a][indexes[a]];\n    //   for (let i = 0; i < 9; i++) {\n    //     if (state.unsolved.has())\n    //   }\n    // }\n    // let unseen = Array.from(cell.suspects);\n    //   create list of seen values\n    //   for each cell\n    //     if value is valid\n    //       add value to seen\n\n    // // Hidden Single check\n    // // identify each cell's suspect values\n    // let axes = [state.rows, state.cols, state.houses];\n    // let indexes = [cell.row, cell.col, cell.house];\n    // let unseen = Array.from(cell.suspects);\n    // for (let a = 0; a < 3; a++) {\n    //   let index = indexes[a];\n    //   let axis = axes[a][index];\n    //   console.log(axis);\n    //   for (let other of axis) {\n\n    //   }\n\n    //   state.unsolved.forEach((other) => {\n    //     if (\n    //       (cell.row === other.row ||\n    //         cell.col === other.col ||\n    //         cell.house === other.house) &&\n    //       !isSameCell(cell, other)\n    //     ) {\n    //       other.suspects.forEach((val) => {\n    //         //console.log(\"DEBUG\" + val);\n    //         unseen = unseen.filter((e) => e !== val);\n    //       });\n    //     }\n    //   });\n    //   if (unseen.length > 0) {\n    //     console.log(\"WHOA\");\n    //     return unseen[0];\n    //   }\n    // }\n    // TODO: create function that runs passed fxn on row, col, house to reduce code duplication\n    // TODO: fix this total fustercluck\n    //for (let i = 0; i < state.unsolved.length && i < 81; i++) {\n    // let target = cell;\n    // //let unseen = Array.from(target.suspects);\n    // state.unsolved.forEach((cell) => {\n    //   if (cell.row === target.row && !isSameCell(target, cell)) {\n    //     cell.suspects.forEach((val) => {\n    //       //console.log(\"DEBUG\" + val);\n    //       unseen = unseen.filter((e) => e !== val);\n    //     });\n    //   }\n    // });\n    // if (unseen.length > 0) {\n    //   return unseen[0];\n    //   //   target = state.unsolved.splice(i, 1)[0];\n    //   //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    // }\n\n    // unseen = Array.from(target.suspects);\n    // //console.log(unseen);\n    // state.unsolved.forEach((cell) => {\n    //   if (cell.col === target.col && !isSameCell(target, cell)) {\n    //     cell.suspects.forEach((val) => {\n    //       //console.log(\"DEBUG\" + val);\n    //       unseen = unseen.filter((e) => e !== val);\n    //     });\n    //   }\n    // });\n    // if (unseen.length > 0) {\n    //   return unseen[0];\n    //   //   target = state.unsolved.splice(i, 1)[0];\n    //   //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    // }\n\n    // unseen = Array.from(target.suspects);\n    // //console.log(unseen);\n    // state.unsolved.forEach((cell) => {\n    //   if (cell.house === target.house && !isSameCell(target, cell)) {\n    //     cell.suspects.forEach((val) => {\n    //       //console.log(\"DEBUG\" + val);\n    //       unseen = unseen.filter((e) => e !== val);\n    //     });\n    //   }\n    // });\n    // if (unseen.length > 0) {\n    //   return unseen[0];\n    //   //   target = state.unsolved.splice(i, 1)[0];\n    //   //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    // }\n\n    return 0;\n    //}\n  },\n};\n"]},"metadata":{},"sourceType":"module"}