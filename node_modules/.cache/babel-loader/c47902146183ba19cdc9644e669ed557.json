{"ast":null,"code":"//import React from \"react\";\n// const HiddenSingleComponent = (props) => {\n//   return <h2>naked single</h2>;\n// };\nexport const hiddenSingle = {\n  name: \"Hidden Single\",\n  check: (cell, state) => {\n    const isSameCell = (c1, c2) => {\n      return c1.row === c2.row && c1.col === c2.col;\n    }; // Hidden Single check\n    // identify each cell's suspect values\n\n\n    let axes = [state.rows, state.cols, state.houses];\n    let indexes = [cell.row, cell.col, cell.houses];\n    let unsolved = Array.from(cell.suspects);\n\n    for (let a = 0; a < 3; a++) {\n      let axis = axes[a];\n      let index = indexes[a];\n    } // TODO: create function that runs passed fxn on row, col, house to reduce code duplication\n    // TODO: fix this total fustercluck\n    //for (let i = 0; i < state.unsolved.length && i < 81; i++) {\n\n\n    let target = cell;\n    let unseen = Array.from(target.suspects);\n    state.unsolved.forEach(cell => {\n      if (cell.row === target.row && !isSameCell(target, cell)) {\n        cell.suspects.forEach(val => {\n          //console.log(\"DEBUG\" + val);\n          unseen = unseen.filter(e => e !== val);\n        });\n      }\n    });\n\n    if (unseen.length > 0) {\n      return unseen[0]; //   target = state.unsolved.splice(i, 1)[0];\n      //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    }\n\n    unseen = Array.from(target.suspects); //console.log(unseen);\n\n    state.unsolved.forEach(cell => {\n      if (cell.col === target.col && !isSameCell(target, cell)) {\n        cell.suspects.forEach(val => {\n          //console.log(\"DEBUG\" + val);\n          unseen = unseen.filter(e => e !== val);\n        });\n      }\n    });\n\n    if (unseen.length > 0) {\n      return unseen[0]; //   target = state.unsolved.splice(i, 1)[0];\n      //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    }\n\n    unseen = Array.from(target.suspects); //console.log(unseen);\n\n    state.unsolved.forEach(cell => {\n      if (cell.house === target.house && !isSameCell(target, cell)) {\n        cell.suspects.forEach(val => {\n          //console.log(\"DEBUG\" + val);\n          unseen = unseen.filter(e => e !== val);\n        });\n      }\n    });\n\n    if (unseen.length > 0) {\n      return unseen[0]; //   target = state.unsolved.splice(i, 1)[0];\n      //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    }\n\n    return 0; //}\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/HiddenSingle.js"],"names":["hiddenSingle","name","check","cell","state","isSameCell","c1","c2","row","col","axes","rows","cols","houses","indexes","unsolved","Array","from","suspects","a","axis","index","target","unseen","forEach","val","filter","e","length","house"],"mappings":"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","sourcesContent":["//import React from \"react\";\n\n// const HiddenSingleComponent = (props) => {\n//   return <h2>naked single</h2>;\n// };\n\nexport const hiddenSingle = {\n  name: \"Hidden Single\",\n  check: (cell, state) => {\n    const isSameCell = (c1, c2) => {\n      return c1.row === c2.row && c1.col === c2.col;\n    };\n    // Hidden Single check\n    // identify each cell's suspect values\n    let axes = [state.rows, state.cols, state.houses];\n    let indexes = [cell.row, cell.col, cell.houses];\n    let unsolved = Array.from(cell.suspects);\n    for (let a = 0; a < 3; a++) {\n      let axis = axes[a];\n      let index = indexes[a];\n    }\n    // TODO: create function that runs passed fxn on row, col, house to reduce code duplication\n    // TODO: fix this total fustercluck\n    //for (let i = 0; i < state.unsolved.length && i < 81; i++) {\n    let target = cell;\n    let unseen = Array.from(target.suspects);\n    state.unsolved.forEach((cell) => {\n      if (cell.row === target.row && !isSameCell(target, cell)) {\n        cell.suspects.forEach((val) => {\n          //console.log(\"DEBUG\" + val);\n          unseen = unseen.filter((e) => e !== val);\n        });\n      }\n    });\n    if (unseen.length > 0) {\n      return unseen[0];\n      //   target = state.unsolved.splice(i, 1)[0];\n      //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    }\n\n    unseen = Array.from(target.suspects);\n    //console.log(unseen);\n    state.unsolved.forEach((cell) => {\n      if (cell.col === target.col && !isSameCell(target, cell)) {\n        cell.suspects.forEach((val) => {\n          //console.log(\"DEBUG\" + val);\n          unseen = unseen.filter((e) => e !== val);\n        });\n      }\n    });\n    if (unseen.length > 0) {\n      return unseen[0];\n      //   target = state.unsolved.splice(i, 1)[0];\n      //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    }\n\n    unseen = Array.from(target.suspects);\n    //console.log(unseen);\n    state.unsolved.forEach((cell) => {\n      if (cell.house === target.house && !isSameCell(target, cell)) {\n        cell.suspects.forEach((val) => {\n          //console.log(\"DEBUG\" + val);\n          unseen = unseen.filter((e) => e !== val);\n        });\n      }\n    });\n    if (unseen.length > 0) {\n      return unseen[0];\n      //   target = state.unsolved.splice(i, 1)[0];\n      //   return reportSolution(\"Hidden Single\", target, unseen[0]);\n    }\n\n    return 0;\n    //}\n  },\n};\n"]},"metadata":{},"sourceType":"module"}