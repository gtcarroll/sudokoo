{"ast":null,"code":"//import React from \"react\";\n// const NakedPair = (props) => {\n//   return <h2>naked pair</h2>;\n// };\nexport const nakedPair = {\n  name: \"Naked Pair\",\n  check: (cell, state, showcase) => {\n    let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    let indexes = [cell.row, cell.col, cell.house]; // for each axis (row, col, house) this cell belongs to...\n\n    for (let a = 0; a < 3; a++) {\n      let axis = axes[a][indexes[a]];\n      let unseen = [];\n\n      for (let i = 0; i < cell.notes.length; i++) {\n        if (cell.notes[i] > 0) unseen.push(i + 1);\n      } // ...for each cell in that axis...\n\n\n      for (let i = 0; i < 9; i++) {\n        let other = axis[i];\n        let isSameCell = cell.col === other.col && cell.row === other.row; // ...if cell is unset and not the same cell...\n\n        if (other.val === 0 && !isSameCell) {\n          // ...remove its suspects from our unseen list.\n          for (let i = 0; i < other.notes.length; i++) {\n            if (other.notes[i] > 0 && unseen.includes(i + 1)) {\n              unseen.splice(unseen.indexOf(i + 1), 1);\n            }\n          }\n        }\n      } // ...if there is any value remaining in our unseen list...\n\n\n      if (cell.suspects.size === 2) {\n        return showcase;\n      } // if (unseen.length > 0) {\n      //   let soln = unseen[0];\n      //   // ...set cell val to soln in state,\n      //   state.sudoku.houses[cell.house][cell.room].val = soln;\n      //   // ...highlight soln value in showcase,\n      //   showcase.houses[cell.house][cell.room].notes[soln - 1] = 2;\n      //   // ...update affected cell notes,\n      //   for (let aff of state.unsolved.values()) {\n      //     if (\n      //       aff.row === cell.row ||\n      //       aff.col === cell.col ||\n      //       aff.house === cell.house\n      //     ) {\n      //       // remove in state\n      //       state.sudoku.houses[aff.house][aff.room].notes[soln - 1] = 0;\n      //       // cross-out in showcase\n      //       showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n      //     }\n      //   }\n      // ...remove from unsolved.\n\n\n      state.unsolved.splice(state.unsolved.indexOf(cell), 1);\n      return showcase;\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["/Users/Gabe/Documents/Projects/sudokoo/src/components/techniques/NakedPair.js"],"names":["nakedPair","name","check","cell","state","showcase","axes","sudoku","rows","cols","houses","indexes","row","col","house","a","axis","unseen","i","notes","length","push","other","isSameCell","val","includes","splice","indexOf","suspects","size","unsolved"],"mappings":"AAAA;AAEA;AACA;AACA;AAEA,OAAO,MAAMA,SAAS,GAAG;AACvBC,EAAAA,IAAI,EAAE,YADiB;AAEvBC,EAAAA,KAAK,EAAE,CAACC,IAAD,EAAOC,KAAP,EAAcC,QAAd,KAA2B;AAChC,QAAIC,IAAI,GAAG,CAACF,KAAK,CAACG,MAAN,CAAaC,IAAd,EAAoBJ,KAAK,CAACG,MAAN,CAAaE,IAAjC,EAAuCL,KAAK,CAACG,MAAN,CAAaG,MAApD,CAAX;AACA,QAAIC,OAAO,GAAG,CAACR,IAAI,CAACS,GAAN,EAAWT,IAAI,CAACU,GAAhB,EAAqBV,IAAI,CAACW,KAA1B,CAAd,CAFgC,CAIhC;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,UAAIC,IAAI,GAAGV,IAAI,CAACS,CAAD,CAAJ,CAAQJ,OAAO,CAACI,CAAD,CAAf,CAAX;AACA,UAAIE,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,IAAI,CAACgB,KAAL,CAAWC,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;AAC1C,YAAIf,IAAI,CAACgB,KAAL,CAAWD,CAAX,IAAgB,CAApB,EAAuBD,MAAM,CAACI,IAAP,CAAYH,CAAC,GAAG,CAAhB;AACxB,OALyB,CAO1B;;;AACA,WAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAII,KAAK,GAAGN,IAAI,CAACE,CAAD,CAAhB;AACA,YAAIK,UAAU,GAAGpB,IAAI,CAACU,GAAL,KAAaS,KAAK,CAACT,GAAnB,IAA0BV,IAAI,CAACS,GAAL,KAAaU,KAAK,CAACV,GAA9D,CAF0B,CAI1B;;AACA,YAAIU,KAAK,CAACE,GAAN,KAAc,CAAd,IAAmB,CAACD,UAAxB,EAAoC;AAClC;AACA,eAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,KAAK,CAACH,KAAN,CAAYC,MAAhC,EAAwCF,CAAC,EAAzC,EAA6C;AAC3C,gBAAII,KAAK,CAACH,KAAN,CAAYD,CAAZ,IAAiB,CAAjB,IAAsBD,MAAM,CAACQ,QAAP,CAAgBP,CAAC,GAAG,CAApB,CAA1B,EAAkD;AAChDD,cAAAA,MAAM,CAACS,MAAP,CAAcT,MAAM,CAACU,OAAP,CAAeT,CAAC,GAAG,CAAnB,CAAd,EAAqC,CAArC;AACD;AACF;AACF;AACF,OArByB,CAsB1B;;;AAEA,UAAIf,IAAI,CAACyB,QAAL,CAAcC,IAAd,KAAuB,CAA3B,EAA8B;AAC5B,eAAOxB,QAAP;AACD,OA1ByB,CA2B1B;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACAD,MAAAA,KAAK,CAAC0B,QAAN,CAAeJ,MAAf,CAAsBtB,KAAK,CAAC0B,QAAN,CAAeH,OAAf,CAAuBxB,IAAvB,CAAtB,EAAoD,CAApD;AACA,aAAOE,QAAP;AACD;;AAED,WAAO,KAAP;AACD;AA9DsB,CAAlB","sourcesContent":["//import React from \"react\";\n\n// const NakedPair = (props) => {\n//   return <h2>naked pair</h2>;\n// };\n\nexport const nakedPair = {\n  name: \"Naked Pair\",\n  check: (cell, state, showcase) => {\n    let axes = [state.sudoku.rows, state.sudoku.cols, state.sudoku.houses];\n    let indexes = [cell.row, cell.col, cell.house];\n\n    // for each axis (row, col, house) this cell belongs to...\n    for (let a = 0; a < 3; a++) {\n      let axis = axes[a][indexes[a]];\n      let unseen = [];\n      for (let i = 0; i < cell.notes.length; i++) {\n        if (cell.notes[i] > 0) unseen.push(i + 1);\n      }\n\n      // ...for each cell in that axis...\n      for (let i = 0; i < 9; i++) {\n        let other = axis[i];\n        let isSameCell = cell.col === other.col && cell.row === other.row;\n\n        // ...if cell is unset and not the same cell...\n        if (other.val === 0 && !isSameCell) {\n          // ...remove its suspects from our unseen list.\n          for (let i = 0; i < other.notes.length; i++) {\n            if (other.notes[i] > 0 && unseen.includes(i + 1)) {\n              unseen.splice(unseen.indexOf(i + 1), 1);\n            }\n          }\n        }\n      }\n      // ...if there is any value remaining in our unseen list...\n\n      if (cell.suspects.size === 2) {\n        return showcase;\n      }\n      // if (unseen.length > 0) {\n      //   let soln = unseen[0];\n\n      //   // ...set cell val to soln in state,\n      //   state.sudoku.houses[cell.house][cell.room].val = soln;\n      //   // ...highlight soln value in showcase,\n      //   showcase.houses[cell.house][cell.room].notes[soln - 1] = 2;\n\n      //   // ...update affected cell notes,\n      //   for (let aff of state.unsolved.values()) {\n      //     if (\n      //       aff.row === cell.row ||\n      //       aff.col === cell.col ||\n      //       aff.house === cell.house\n      //     ) {\n      //       // remove in state\n      //       state.sudoku.houses[aff.house][aff.room].notes[soln - 1] = 0;\n      //       // cross-out in showcase\n      //       showcase.houses[aff.house][aff.room].notes[soln - 1] = -1;\n      //     }\n      //   }\n\n      // ...remove from unsolved.\n      state.unsolved.splice(state.unsolved.indexOf(cell), 1);\n      return showcase;\n    }\n\n    return false;\n  },\n};\n"]},"metadata":{},"sourceType":"module"}